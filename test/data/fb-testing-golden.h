// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_TESTING_FB_H_
#define FLATBUFFERS_GENERATED_TESTING_FB_H_

#include "flatbuffers/flatbuffers.h"

#include "fb/vocab_generated.h"
#include "fb/coord_generated.h"

namespace fb {
namespace MySumtype {

struct none;
struct noneBuilder;

struct some;
struct someBuilder;

struct more;
struct moreBuilder;

}  // namespace MySumtype

struct MySumtype_t;
struct MySumtype_tBuilder;

struct Weapon;
struct WeaponBuilder;

struct Vec2;

struct Vec3;

struct Pair_Vec2_int;

struct Pair_int_Weapon;
struct Pair_int_WeaponBuilder;

struct SetTester;
struct SetTesterBuilder;

struct MapTester1;
struct MapTester1Builder;

struct MapTester2;
struct MapTester2Builder;

struct Empty;
struct EmptyBuilder;

struct MyVariant;
struct MyVariantBuilder;

struct MyVariantNoIndex;
struct MyVariantNoIndexBuilder;

struct MyFloatVariant;
struct MyFloatVariantBuilder;

struct MyFlatQueues;
struct MyFlatQueuesBuilder;

struct Pair_Coord_String;
struct Pair_Coord_StringBuilder;

struct Matrix_String;
struct Matrix_StringBuilder;

namespace OnOffState {

struct off;
struct offBuilder;

struct on;
struct onBuilder;

struct switching_on;
struct switching_onBuilder;

struct switching_off;
struct switching_offBuilder;

}  // namespace OnOffState

struct OnOffState_t;
struct OnOffState_tBuilder;

struct OnOffFsm;
struct OnOffFsmBuilder;

struct Monster;
struct MonsterBuilder;

namespace MyVariant2 {

struct first;
struct firstBuilder;

struct second;
struct secondBuilder;

struct third;
struct thirdBuilder;

}  // namespace MyVariant2

struct MyVariant2_t;
struct MyVariant2_tBuilder;

namespace MySumtype {

inline const flatbuffers::TypeTable *noneTypeTable();

inline const flatbuffers::TypeTable *someTypeTable();

inline const flatbuffers::TypeTable *moreTypeTable();

}  // namespace MySumtype

inline const flatbuffers::TypeTable *MySumtype_tTypeTable();

inline const flatbuffers::TypeTable *WeaponTypeTable();

inline const flatbuffers::TypeTable *Vec2TypeTable();

inline const flatbuffers::TypeTable *Vec3TypeTable();

inline const flatbuffers::TypeTable *Pair_Vec2_intTypeTable();

inline const flatbuffers::TypeTable *Pair_int_WeaponTypeTable();

inline const flatbuffers::TypeTable *SetTesterTypeTable();

inline const flatbuffers::TypeTable *MapTester1TypeTable();

inline const flatbuffers::TypeTable *MapTester2TypeTable();

inline const flatbuffers::TypeTable *EmptyTypeTable();

inline const flatbuffers::TypeTable *MyVariantTypeTable();

inline const flatbuffers::TypeTable *MyVariantNoIndexTypeTable();

inline const flatbuffers::TypeTable *MyFloatVariantTypeTable();

inline const flatbuffers::TypeTable *MyFlatQueuesTypeTable();

inline const flatbuffers::TypeTable *Pair_Coord_StringTypeTable();

inline const flatbuffers::TypeTable *Matrix_StringTypeTable();

namespace OnOffState {

inline const flatbuffers::TypeTable *offTypeTable();

inline const flatbuffers::TypeTable *onTypeTable();

inline const flatbuffers::TypeTable *switching_onTypeTable();

inline const flatbuffers::TypeTable *switching_offTypeTable();

}  // namespace OnOffState

inline const flatbuffers::TypeTable *OnOffState_tTypeTable();

inline const flatbuffers::TypeTable *OnOffFsmTypeTable();

inline const flatbuffers::TypeTable *MonsterTypeTable();

namespace MyVariant2 {

inline const flatbuffers::TypeTable *firstTypeTable();

inline const flatbuffers::TypeTable *secondTypeTable();

inline const flatbuffers::TypeTable *thirdTypeTable();

}  // namespace MyVariant2

inline const flatbuffers::TypeTable *MyVariant2_tTypeTable();

enum class e_hand : int8_t {
  left = 0,
  right = 1,
  MIN = left,
  MAX = right
};

inline const e_hand (&EnumValuese_hand())[2] {
  static const e_hand values[] = {
    e_hand::left,
    e_hand::right
  };
  return values;
}

inline const char * const *EnumNamese_hand() {
  static const char * const names[3] = {
    "left",
    "right",
    nullptr
  };
  return names;
}

inline const char *EnumNamee_hand(e_hand e) {
  if (flatbuffers::IsOutRange(e, e_hand::left, e_hand::right)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamese_hand()[index];
}

enum class e_color : int8_t {
  red = 0,
  green = 1,
  blue = 2,
  MIN = red,
  MAX = blue
};

inline const e_color (&EnumValuese_color())[3] {
  static const e_color values[] = {
    e_color::red,
    e_color::green,
    e_color::blue
  };
  return values;
}

inline const char * const *EnumNamese_color() {
  static const char * const names[4] = {
    "red",
    "green",
    "blue",
    nullptr
  };
  return names;
}

inline const char *EnumNamee_color(e_color e) {
  if (flatbuffers::IsOutRange(e, e_color::red, e_color::blue)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamese_color()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec2 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;

 public:
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Vec2TypeTable();
  }
  Vec2()
      : x_(0),
        y_(0) {
  }
  Vec2(float _x, float _y)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return x();
    else if constexpr (Index == 1) return y();
    else static_assert(Index != Index, "Invalid Field Index");
  }
};
FLATBUFFERS_STRUCT_END(Vec2, 8);

struct Vec2::Traits {
  using type = Vec2;
  static constexpr auto name = "Vec2";
  static constexpr auto fully_qualified_name = "fb.Vec2";
  static constexpr std::array<const char *, 2> field_names = {
    "x",
    "y"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
  static constexpr size_t fields_number = 2;
};

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec3 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Vec3TypeTable();
  }
  Vec3()
      : x_(0),
        y_(0),
        z_(0) {
  }
  Vec3(float _x, float _y, float _z)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return x();
    else if constexpr (Index == 1) return y();
    else if constexpr (Index == 2) return z();
    else static_assert(Index != Index, "Invalid Field Index");
  }
};
FLATBUFFERS_STRUCT_END(Vec3, 12);

struct Vec3::Traits {
  using type = Vec3;
  static constexpr auto name = "Vec3";
  static constexpr auto fully_qualified_name = "fb.Vec3";
  static constexpr std::array<const char *, 3> field_names = {
    "x",
    "y",
    "z"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
  static constexpr size_t fields_number = 3;
};

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Pair_Vec2_int FLATBUFFERS_FINAL_CLASS {
 private:
  fb::Vec2 fst_;
  int32_t snd_;

 public:
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Pair_Vec2_intTypeTable();
  }
  Pair_Vec2_int()
      : fst_(),
        snd_(0) {
  }
  Pair_Vec2_int(const fb::Vec2 &_fst, int32_t _snd)
      : fst_(_fst),
        snd_(flatbuffers::EndianScalar(_snd)) {
  }
  const fb::Vec2 &fst() const {
    return fst_;
  }
  int32_t snd() const {
    return flatbuffers::EndianScalar(snd_);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return fst();
    else if constexpr (Index == 1) return snd();
    else static_assert(Index != Index, "Invalid Field Index");
  }
};
FLATBUFFERS_STRUCT_END(Pair_Vec2_int, 12);

struct Pair_Vec2_int::Traits {
  using type = Pair_Vec2_int;
  static constexpr auto name = "Pair_Vec2_int";
  static constexpr auto fully_qualified_name = "fb.Pair_Vec2_int";
  static constexpr std::array<const char *, 2> field_names = {
    "fst",
    "snd"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
  static constexpr size_t fields_number = 2;
};

namespace MySumtype {

struct none FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef noneBuilder Builder;
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return noneTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct noneBuilder {
  typedef none Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit noneBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<none> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<none>(end);
    return o;
  }
};

inline flatbuffers::Offset<none> Createnone(
    flatbuffers::FlatBufferBuilder &_fbb) {
  noneBuilder builder_(_fbb);
  return builder_.Finish();
}

struct none::Traits {
  using type = none;
  static auto constexpr Create = Createnone;
  static constexpr auto name = "none";
  static constexpr auto fully_qualified_name = "fb.MySumtype.none";
  static constexpr std::array<const char *, 0> field_names = {};
  static constexpr size_t fields_number = 0;
};

struct some FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef someBuilder Builder;
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return someTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_S = 4,
    VT_Y = 6
  };
  const flatbuffers::String *s() const {
    return GetPointer<const flatbuffers::String *>(VT_S);
  }
  int32_t y() const {
    return GetField<int32_t>(VT_Y, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return s();
    else if constexpr (Index == 1) return y();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_S) &&
           verifier.VerifyString(s()) &&
           VerifyField<int32_t>(verifier, VT_Y) &&
           verifier.EndTable();
  }
};

struct someBuilder {
  typedef some Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_s(flatbuffers::Offset<flatbuffers::String> s) {
    fbb_.AddOffset(some::VT_S, s);
  }
  void add_y(int32_t y) {
    fbb_.AddElement<int32_t>(some::VT_Y, y, 0);
  }
  explicit someBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<some> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<some>(end);
    return o;
  }
};

inline flatbuffers::Offset<some> Createsome(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> s = 0,
    int32_t y = 0) {
  someBuilder builder_(_fbb);
  builder_.add_y(y);
  builder_.add_s(s);
  return builder_.Finish();
}

struct some::Traits {
  using type = some;
  static auto constexpr Create = Createsome;
  static constexpr auto name = "some";
  static constexpr auto fully_qualified_name = "fb.MySumtype.some";
  static constexpr std::array<const char *, 2> field_names = {
    "s",
    "y"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
  static constexpr size_t fields_number = 2;
};

inline flatbuffers::Offset<some> CreatesomeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *s = nullptr,
    int32_t y = 0) {
  auto s__ = s ? _fbb.CreateString(s) : 0;
  return fb::MySumtype::Createsome(
      _fbb,
      s__,
      y);
}

struct more FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef moreBuilder Builder;
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return moreTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_D = 4
  };
  double d() const {
    return GetField<double>(VT_D, 0.0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return d();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_D) &&
           verifier.EndTable();
  }
};

struct moreBuilder {
  typedef more Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_d(double d) {
    fbb_.AddElement<double>(more::VT_D, d, 0.0);
  }
  explicit moreBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<more> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<more>(end);
    return o;
  }
};

inline flatbuffers::Offset<more> Createmore(
    flatbuffers::FlatBufferBuilder &_fbb,
    double d = 0.0) {
  moreBuilder builder_(_fbb);
  builder_.add_d(d);
  return builder_.Finish();
}

struct more::Traits {
  using type = more;
  static auto constexpr Create = Createmore;
  static constexpr auto name = "more";
  static constexpr auto fully_qualified_name = "fb.MySumtype.more";
  static constexpr std::array<const char *, 1> field_names = {
    "d"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
  static constexpr size_t fields_number = 1;
};

}  // namespace MySumtype

struct MySumtype_t FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MySumtype_tBuilder Builder;
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MySumtype_tTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NONE = 4,
    VT_SOME = 6,
    VT_MORE = 8
  };
  const fb::MySumtype::none *none() const {
    return GetPointer<const fb::MySumtype::none *>(VT_NONE);
  }
  const fb::MySumtype::some *some() const {
    return GetPointer<const fb::MySumtype::some *>(VT_SOME);
  }
  const fb::MySumtype::more *more() const {
    return GetPointer<const fb::MySumtype::more *>(VT_MORE);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return none();
    else if constexpr (Index == 1) return some();
    else if constexpr (Index == 2) return more();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NONE) &&
           verifier.VerifyTable(none()) &&
           VerifyOffset(verifier, VT_SOME) &&
           verifier.VerifyTable(some()) &&
           VerifyOffset(verifier, VT_MORE) &&
           verifier.VerifyTable(more()) &&
           verifier.EndTable();
  }
};

struct MySumtype_tBuilder {
  typedef MySumtype_t Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_none(flatbuffers::Offset<fb::MySumtype::none> none) {
    fbb_.AddOffset(MySumtype_t::VT_NONE, none);
  }
  void add_some(flatbuffers::Offset<fb::MySumtype::some> some) {
    fbb_.AddOffset(MySumtype_t::VT_SOME, some);
  }
  void add_more(flatbuffers::Offset<fb::MySumtype::more> more) {
    fbb_.AddOffset(MySumtype_t::VT_MORE, more);
  }
  explicit MySumtype_tBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MySumtype_t> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MySumtype_t>(end);
    return o;
  }
};

inline flatbuffers::Offset<MySumtype_t> CreateMySumtype_t(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MySumtype::none> none = 0,
    flatbuffers::Offset<fb::MySumtype::some> some = 0,
    flatbuffers::Offset<fb::MySumtype::more> more = 0) {
  MySumtype_tBuilder builder_(_fbb);
  builder_.add_more(more);
  builder_.add_some(some);
  builder_.add_none(none);
  return builder_.Finish();
}

struct MySumtype_t::Traits {
  using type = MySumtype_t;
  static auto constexpr Create = CreateMySumtype_t;
  static constexpr auto name = "MySumtype_t";
  static constexpr auto fully_qualified_name = "fb.MySumtype_t";
  static constexpr std::array<const char *, 3> field_names = {
    "none",
    "some",
    "more"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
  static constexpr size_t fields_number = 3;
};

struct Weapon FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef WeaponBuilder Builder;
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return WeaponTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_DAMAGE = 6
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  int16_t damage() const {
    return GetField<int16_t>(VT_DAMAGE, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return name();
    else if constexpr (Index == 1) return damage();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int16_t>(verifier, VT_DAMAGE) &&
           verifier.EndTable();
  }
};

struct WeaponBuilder {
  typedef Weapon Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Weapon::VT_NAME, name);
  }
  void add_damage(int16_t damage) {
    fbb_.AddElement<int16_t>(Weapon::VT_DAMAGE, damage, 0);
  }
  explicit WeaponBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Weapon> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Weapon>(end);
    return o;
  }
};

inline flatbuffers::Offset<Weapon> CreateWeapon(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    int16_t damage = 0) {
  WeaponBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_damage(damage);
  return builder_.Finish();
}

struct Weapon::Traits {
  using type = Weapon;
  static auto constexpr Create = CreateWeapon;
  static constexpr auto name = "Weapon";
  static constexpr auto fully_qualified_name = "fb.Weapon";
  static constexpr std::array<const char *, 2> field_names = {
    "name",
    "damage"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
  static constexpr size_t fields_number = 2;
};

inline flatbuffers::Offset<Weapon> CreateWeaponDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    int16_t damage = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return fb::CreateWeapon(
      _fbb,
      name__,
      damage);
}

struct Pair_int_Weapon FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Pair_int_WeaponBuilder Builder;
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Pair_int_WeaponTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FST = 4,
    VT_SND = 6
  };
  int32_t fst() const {
    return GetField<int32_t>(VT_FST, 0);
  }
  const fb::Weapon *snd() const {
    return GetPointer<const fb::Weapon *>(VT_SND);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return fst();
    else if constexpr (Index == 1) return snd();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FST) &&
           VerifyOffset(verifier, VT_SND) &&
           verifier.VerifyTable(snd()) &&
           verifier.EndTable();
  }
};

struct Pair_int_WeaponBuilder {
  typedef Pair_int_Weapon Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fst(int32_t fst) {
    fbb_.AddElement<int32_t>(Pair_int_Weapon::VT_FST, fst, 0);
  }
  void add_snd(flatbuffers::Offset<fb::Weapon> snd) {
    fbb_.AddOffset(Pair_int_Weapon::VT_SND, snd);
  }
  explicit Pair_int_WeaponBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Pair_int_Weapon> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Pair_int_Weapon>(end);
    return o;
  }
};

inline flatbuffers::Offset<Pair_int_Weapon> CreatePair_int_Weapon(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t fst = 0,
    flatbuffers::Offset<fb::Weapon> snd = 0) {
  Pair_int_WeaponBuilder builder_(_fbb);
  builder_.add_snd(snd);
  builder_.add_fst(fst);
  return builder_.Finish();
}

struct Pair_int_Weapon::Traits {
  using type = Pair_int_Weapon;
  static auto constexpr Create = CreatePair_int_Weapon;
  static constexpr auto name = "Pair_int_Weapon";
  static constexpr auto fully_qualified_name = "fb.Pair_int_Weapon";
  static constexpr std::array<const char *, 2> field_names = {
    "fst",
    "snd"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
  static constexpr size_t fields_number = 2;
};

struct SetTester FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SetTesterBuilder Builder;
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SetTesterTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SET = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *set() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_SET);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return set();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SET) &&
           verifier.VerifyVector(set()) &&
           verifier.VerifyVectorOfStrings(set()) &&
           verifier.EndTable();
  }
};

struct SetTesterBuilder {
  typedef SetTester Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_set(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> set) {
    fbb_.AddOffset(SetTester::VT_SET, set);
  }
  explicit SetTesterBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SetTester> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SetTester>(end);
    return o;
  }
};

inline flatbuffers::Offset<SetTester> CreateSetTester(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> set = 0) {
  SetTesterBuilder builder_(_fbb);
  builder_.add_set(set);
  return builder_.Finish();
}

struct SetTester::Traits {
  using type = SetTester;
  static auto constexpr Create = CreateSetTester;
  static constexpr auto name = "SetTester";
  static constexpr auto fully_qualified_name = "fb.SetTester";
  static constexpr std::array<const char *, 1> field_names = {
    "set"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
  static constexpr size_t fields_number = 1;
};

inline flatbuffers::Offset<SetTester> CreateSetTesterDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *set = nullptr) {
  auto set__ = set ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*set) : 0;
  return fb::CreateSetTester(
      _fbb,
      set__);
}

struct MapTester1 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MapTester1Builder Builder;
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MapTester1TypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MAP = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<fb::Pair_string_int>> *map() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<fb::Pair_string_int>> *>(VT_MAP);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return map();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MAP) &&
           verifier.VerifyVector(map()) &&
           verifier.VerifyVectorOfTables(map()) &&
           verifier.EndTable();
  }
};

struct MapTester1Builder {
  typedef MapTester1 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_map(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fb::Pair_string_int>>> map) {
    fbb_.AddOffset(MapTester1::VT_MAP, map);
  }
  explicit MapTester1Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MapTester1> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MapTester1>(end);
    return o;
  }
};

inline flatbuffers::Offset<MapTester1> CreateMapTester1(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fb::Pair_string_int>>> map = 0) {
  MapTester1Builder builder_(_fbb);
  builder_.add_map(map);
  return builder_.Finish();
}

struct MapTester1::Traits {
  using type = MapTester1;
  static auto constexpr Create = CreateMapTester1;
  static constexpr auto name = "MapTester1";
  static constexpr auto fully_qualified_name = "fb.MapTester1";
  static constexpr std::array<const char *, 1> field_names = {
    "map"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
  static constexpr size_t fields_number = 1;
};

inline flatbuffers::Offset<MapTester1> CreateMapTester1Direct(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<fb::Pair_string_int>> *map = nullptr) {
  auto map__ = map ? _fbb.CreateVector<flatbuffers::Offset<fb::Pair_string_int>>(*map) : 0;
  return fb::CreateMapTester1(
      _fbb,
      map__);
}

struct MapTester2 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MapTester2Builder Builder;
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MapTester2TypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MAP = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<fb::Pair_int_int>> *map() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<fb::Pair_int_int>> *>(VT_MAP);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return map();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MAP) &&
           verifier.VerifyVector(map()) &&
           verifier.VerifyVectorOfTables(map()) &&
           verifier.EndTable();
  }
};

struct MapTester2Builder {
  typedef MapTester2 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_map(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fb::Pair_int_int>>> map) {
    fbb_.AddOffset(MapTester2::VT_MAP, map);
  }
  explicit MapTester2Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MapTester2> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MapTester2>(end);
    return o;
  }
};

inline flatbuffers::Offset<MapTester2> CreateMapTester2(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fb::Pair_int_int>>> map = 0) {
  MapTester2Builder builder_(_fbb);
  builder_.add_map(map);
  return builder_.Finish();
}

struct MapTester2::Traits {
  using type = MapTester2;
  static auto constexpr Create = CreateMapTester2;
  static constexpr auto name = "MapTester2";
  static constexpr auto fully_qualified_name = "fb.MapTester2";
  static constexpr std::array<const char *, 1> field_names = {
    "map"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
  static constexpr size_t fields_number = 1;
};

inline flatbuffers::Offset<MapTester2> CreateMapTester2Direct(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<fb::Pair_int_int>> *map = nullptr) {
  auto map__ = map ? _fbb.CreateVector<flatbuffers::Offset<fb::Pair_int_int>>(*map) : 0;
  return fb::CreateMapTester2(
      _fbb,
      map__);
}

struct Empty FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EmptyBuilder Builder;
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return EmptyTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct EmptyBuilder {
  typedef Empty Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit EmptyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Empty> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Empty>(end);
    return o;
  }
};

inline flatbuffers::Offset<Empty> CreateEmpty(
    flatbuffers::FlatBufferBuilder &_fbb) {
  EmptyBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Empty::Traits {
  using type = Empty;
  static auto constexpr Create = CreateEmpty;
  static constexpr auto name = "Empty";
  static constexpr auto fully_qualified_name = "fb.Empty";
  static constexpr std::array<const char *, 0> field_names = {};
  static constexpr size_t fields_number = 0;
};

struct MyVariant FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MyVariantBuilder Builder;
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MyVariantTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACTIVE_INDEX = 4,
    VT_ONE = 6,
    VT_TWO = 8,
    VT_THREE = 10,
    VT_FOUR = 12
  };
  int32_t active_index() const {
    return GetField<int32_t>(VT_ACTIVE_INDEX, 0);
  }
  int32_t one() const {
    return GetField<int32_t>(VT_ONE, 0);
  }
  const fb::Vec2 *two() const {
    return GetStruct<const fb::Vec2 *>(VT_TWO);
  }
  const fb::Weapon *three() const {
    return GetPointer<const fb::Weapon *>(VT_THREE);
  }
  fb::e_color four() const {
    return static_cast<fb::e_color>(GetField<int8_t>(VT_FOUR, 0));
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return active_index();
    else if constexpr (Index == 1) return one();
    else if constexpr (Index == 2) return two();
    else if constexpr (Index == 3) return three();
    else if constexpr (Index == 4) return four();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ACTIVE_INDEX) &&
           VerifyField<int32_t>(verifier, VT_ONE) &&
           VerifyField<fb::Vec2>(verifier, VT_TWO) &&
           VerifyOffset(verifier, VT_THREE) &&
           verifier.VerifyTable(three()) &&
           VerifyField<int8_t>(verifier, VT_FOUR) &&
           verifier.EndTable();
  }
};

struct MyVariantBuilder {
  typedef MyVariant Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_active_index(int32_t active_index) {
    fbb_.AddElement<int32_t>(MyVariant::VT_ACTIVE_INDEX, active_index, 0);
  }
  void add_one(int32_t one) {
    fbb_.AddElement<int32_t>(MyVariant::VT_ONE, one, 0);
  }
  void add_two(const fb::Vec2 *two) {
    fbb_.AddStruct(MyVariant::VT_TWO, two);
  }
  void add_three(flatbuffers::Offset<fb::Weapon> three) {
    fbb_.AddOffset(MyVariant::VT_THREE, three);
  }
  void add_four(fb::e_color four) {
    fbb_.AddElement<int8_t>(MyVariant::VT_FOUR, static_cast<int8_t>(four), 0);
  }
  explicit MyVariantBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MyVariant> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MyVariant>(end);
    return o;
  }
};

inline flatbuffers::Offset<MyVariant> CreateMyVariant(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t active_index = 0,
    int32_t one = 0,
    const fb::Vec2 *two = 0,
    flatbuffers::Offset<fb::Weapon> three = 0,
    fb::e_color four = fb::e_color::red) {
  MyVariantBuilder builder_(_fbb);
  builder_.add_three(three);
  builder_.add_two(two);
  builder_.add_one(one);
  builder_.add_active_index(active_index);
  builder_.add_four(four);
  return builder_.Finish();
}

struct MyVariant::Traits {
  using type = MyVariant;
  static auto constexpr Create = CreateMyVariant;
  static constexpr auto name = "MyVariant";
  static constexpr auto fully_qualified_name = "fb.MyVariant";
  static constexpr std::array<const char *, 5> field_names = {
    "active_index",
    "one",
    "two",
    "three",
    "four"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
  static constexpr size_t fields_number = 5;
};

struct MyVariantNoIndex FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MyVariantNoIndexBuilder Builder;
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MyVariantNoIndexTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TWO = 4,
    VT_THREE = 6,
    VT_FOUR = 8
  };
  const fb::Vec2 *two() const {
    return GetStruct<const fb::Vec2 *>(VT_TWO);
  }
  const fb::Weapon *three() const {
    return GetPointer<const fb::Weapon *>(VT_THREE);
  }
  const fb::Weapon *four() const {
    return GetPointer<const fb::Weapon *>(VT_FOUR);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return two();
    else if constexpr (Index == 1) return three();
    else if constexpr (Index == 2) return four();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<fb::Vec2>(verifier, VT_TWO) &&
           VerifyOffset(verifier, VT_THREE) &&
           verifier.VerifyTable(three()) &&
           VerifyOffset(verifier, VT_FOUR) &&
           verifier.VerifyTable(four()) &&
           verifier.EndTable();
  }
};

struct MyVariantNoIndexBuilder {
  typedef MyVariantNoIndex Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_two(const fb::Vec2 *two) {
    fbb_.AddStruct(MyVariantNoIndex::VT_TWO, two);
  }
  void add_three(flatbuffers::Offset<fb::Weapon> three) {
    fbb_.AddOffset(MyVariantNoIndex::VT_THREE, three);
  }
  void add_four(flatbuffers::Offset<fb::Weapon> four) {
    fbb_.AddOffset(MyVariantNoIndex::VT_FOUR, four);
  }
  explicit MyVariantNoIndexBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MyVariantNoIndex> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MyVariantNoIndex>(end);
    return o;
  }
};

inline flatbuffers::Offset<MyVariantNoIndex> CreateMyVariantNoIndex(
    flatbuffers::FlatBufferBuilder &_fbb,
    const fb::Vec2 *two = 0,
    flatbuffers::Offset<fb::Weapon> three = 0,
    flatbuffers::Offset<fb::Weapon> four = 0) {
  MyVariantNoIndexBuilder builder_(_fbb);
  builder_.add_four(four);
  builder_.add_three(three);
  builder_.add_two(two);
  return builder_.Finish();
}

struct MyVariantNoIndex::Traits {
  using type = MyVariantNoIndex;
  static auto constexpr Create = CreateMyVariantNoIndex;
  static constexpr auto name = "MyVariantNoIndex";
  static constexpr auto fully_qualified_name = "fb.MyVariantNoIndex";
  static constexpr std::array<const char *, 3> field_names = {
    "two",
    "three",
    "four"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
  static constexpr size_t fields_number = 3;
};

struct MyFloatVariant FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MyFloatVariantBuilder Builder;
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MyFloatVariantTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACTIVE_INDEX = 4,
    VT_ONE = 6,
    VT_TWO = 8,
    VT_THREE = 10,
    VT_FOUR = 12
  };
  int32_t active_index() const {
    return GetField<int32_t>(VT_ACTIVE_INDEX, 0);
  }
  float one() const {
    return GetField<float>(VT_ONE, 0.0f);
  }
  float two() const {
    return GetField<float>(VT_TWO, 0.0f);
  }
  float three() const {
    return GetField<float>(VT_THREE, 0.0f);
  }
  float four() const {
    return GetField<float>(VT_FOUR, 0.0f);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return active_index();
    else if constexpr (Index == 1) return one();
    else if constexpr (Index == 2) return two();
    else if constexpr (Index == 3) return three();
    else if constexpr (Index == 4) return four();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ACTIVE_INDEX) &&
           VerifyField<float>(verifier, VT_ONE) &&
           VerifyField<float>(verifier, VT_TWO) &&
           VerifyField<float>(verifier, VT_THREE) &&
           VerifyField<float>(verifier, VT_FOUR) &&
           verifier.EndTable();
  }
};

struct MyFloatVariantBuilder {
  typedef MyFloatVariant Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_active_index(int32_t active_index) {
    fbb_.AddElement<int32_t>(MyFloatVariant::VT_ACTIVE_INDEX, active_index, 0);
  }
  void add_one(float one) {
    fbb_.AddElement<float>(MyFloatVariant::VT_ONE, one, 0.0f);
  }
  void add_two(float two) {
    fbb_.AddElement<float>(MyFloatVariant::VT_TWO, two, 0.0f);
  }
  void add_three(float three) {
    fbb_.AddElement<float>(MyFloatVariant::VT_THREE, three, 0.0f);
  }
  void add_four(float four) {
    fbb_.AddElement<float>(MyFloatVariant::VT_FOUR, four, 0.0f);
  }
  explicit MyFloatVariantBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MyFloatVariant> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MyFloatVariant>(end);
    return o;
  }
};

inline flatbuffers::Offset<MyFloatVariant> CreateMyFloatVariant(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t active_index = 0,
    float one = 0.0f,
    float two = 0.0f,
    float three = 0.0f,
    float four = 0.0f) {
  MyFloatVariantBuilder builder_(_fbb);
  builder_.add_four(four);
  builder_.add_three(three);
  builder_.add_two(two);
  builder_.add_one(one);
  builder_.add_active_index(active_index);
  return builder_.Finish();
}

struct MyFloatVariant::Traits {
  using type = MyFloatVariant;
  static auto constexpr Create = CreateMyFloatVariant;
  static constexpr auto name = "MyFloatVariant";
  static constexpr auto fully_qualified_name = "fb.MyFloatVariant";
  static constexpr std::array<const char *, 5> field_names = {
    "active_index",
    "one",
    "two",
    "three",
    "four"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
  static constexpr size_t fields_number = 5;
};

struct MyFlatQueues FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MyFlatQueuesBuilder Builder;
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MyFlatQueuesTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_Q1 = 4,
    VT_Q2 = 6,
    VT_DQ = 8
  };
  const flatbuffers::Vector<int32_t> *q1() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_Q1);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *q2() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_Q2);
  }
  const flatbuffers::Vector<int32_t> *dq() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_DQ);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return q1();
    else if constexpr (Index == 1) return q2();
    else if constexpr (Index == 2) return dq();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_Q1) &&
           verifier.VerifyVector(q1()) &&
           VerifyOffset(verifier, VT_Q2) &&
           verifier.VerifyVector(q2()) &&
           verifier.VerifyVectorOfStrings(q2()) &&
           VerifyOffset(verifier, VT_DQ) &&
           verifier.VerifyVector(dq()) &&
           verifier.EndTable();
  }
};

struct MyFlatQueuesBuilder {
  typedef MyFlatQueues Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_q1(flatbuffers::Offset<flatbuffers::Vector<int32_t>> q1) {
    fbb_.AddOffset(MyFlatQueues::VT_Q1, q1);
  }
  void add_q2(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> q2) {
    fbb_.AddOffset(MyFlatQueues::VT_Q2, q2);
  }
  void add_dq(flatbuffers::Offset<flatbuffers::Vector<int32_t>> dq) {
    fbb_.AddOffset(MyFlatQueues::VT_DQ, dq);
  }
  explicit MyFlatQueuesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MyFlatQueues> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MyFlatQueues>(end);
    return o;
  }
};

inline flatbuffers::Offset<MyFlatQueues> CreateMyFlatQueues(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> q1 = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> q2 = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> dq = 0) {
  MyFlatQueuesBuilder builder_(_fbb);
  builder_.add_dq(dq);
  builder_.add_q2(q2);
  builder_.add_q1(q1);
  return builder_.Finish();
}

struct MyFlatQueues::Traits {
  using type = MyFlatQueues;
  static auto constexpr Create = CreateMyFlatQueues;
  static constexpr auto name = "MyFlatQueues";
  static constexpr auto fully_qualified_name = "fb.MyFlatQueues";
  static constexpr std::array<const char *, 3> field_names = {
    "q1",
    "q2",
    "dq"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
  static constexpr size_t fields_number = 3;
};

inline flatbuffers::Offset<MyFlatQueues> CreateMyFlatQueuesDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *q1 = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *q2 = nullptr,
    const std::vector<int32_t> *dq = nullptr) {
  auto q1__ = q1 ? _fbb.CreateVector<int32_t>(*q1) : 0;
  auto q2__ = q2 ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*q2) : 0;
  auto dq__ = dq ? _fbb.CreateVector<int32_t>(*dq) : 0;
  return fb::CreateMyFlatQueues(
      _fbb,
      q1__,
      q2__,
      dq__);
}

struct Pair_Coord_String FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Pair_Coord_StringBuilder Builder;
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Pair_Coord_StringTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FST = 4,
    VT_SND = 6
  };
  const fb::Coord *fst() const {
    return GetStruct<const fb::Coord *>(VT_FST);
  }
  const flatbuffers::String *snd() const {
    return GetPointer<const flatbuffers::String *>(VT_SND);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return fst();
    else if constexpr (Index == 1) return snd();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<fb::Coord>(verifier, VT_FST) &&
           VerifyOffset(verifier, VT_SND) &&
           verifier.VerifyString(snd()) &&
           verifier.EndTable();
  }
};

struct Pair_Coord_StringBuilder {
  typedef Pair_Coord_String Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fst(const fb::Coord *fst) {
    fbb_.AddStruct(Pair_Coord_String::VT_FST, fst);
  }
  void add_snd(flatbuffers::Offset<flatbuffers::String> snd) {
    fbb_.AddOffset(Pair_Coord_String::VT_SND, snd);
  }
  explicit Pair_Coord_StringBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Pair_Coord_String> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Pair_Coord_String>(end);
    return o;
  }
};

inline flatbuffers::Offset<Pair_Coord_String> CreatePair_Coord_String(
    flatbuffers::FlatBufferBuilder &_fbb,
    const fb::Coord *fst = 0,
    flatbuffers::Offset<flatbuffers::String> snd = 0) {
  Pair_Coord_StringBuilder builder_(_fbb);
  builder_.add_snd(snd);
  builder_.add_fst(fst);
  return builder_.Finish();
}

struct Pair_Coord_String::Traits {
  using type = Pair_Coord_String;
  static auto constexpr Create = CreatePair_Coord_String;
  static constexpr auto name = "Pair_Coord_String";
  static constexpr auto fully_qualified_name = "fb.Pair_Coord_String";
  static constexpr std::array<const char *, 2> field_names = {
    "fst",
    "snd"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
  static constexpr size_t fields_number = 2;
};

inline flatbuffers::Offset<Pair_Coord_String> CreatePair_Coord_StringDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const fb::Coord *fst = 0,
    const char *snd = nullptr) {
  auto snd__ = snd ? _fbb.CreateString(snd) : 0;
  return fb::CreatePair_Coord_String(
      _fbb,
      fst,
      snd__);
}

struct Matrix_String FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Matrix_StringBuilder Builder;
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Matrix_StringTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SIZE = 4,
    VT_DATA = 6
  };
  const fb::Delta *size() const {
    return GetStruct<const fb::Delta *>(VT_SIZE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<fb::Pair_Coord_String>> *data() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<fb::Pair_Coord_String>> *>(VT_DATA);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return size();
    else if constexpr (Index == 1) return data();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<fb::Delta>(verifier, VT_SIZE) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.VerifyVectorOfTables(data()) &&
           verifier.EndTable();
  }
};

struct Matrix_StringBuilder {
  typedef Matrix_String Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_size(const fb::Delta *size) {
    fbb_.AddStruct(Matrix_String::VT_SIZE, size);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fb::Pair_Coord_String>>> data) {
    fbb_.AddOffset(Matrix_String::VT_DATA, data);
  }
  explicit Matrix_StringBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Matrix_String> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Matrix_String>(end);
    return o;
  }
};

inline flatbuffers::Offset<Matrix_String> CreateMatrix_String(
    flatbuffers::FlatBufferBuilder &_fbb,
    const fb::Delta *size = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fb::Pair_Coord_String>>> data = 0) {
  Matrix_StringBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_size(size);
  return builder_.Finish();
}

struct Matrix_String::Traits {
  using type = Matrix_String;
  static auto constexpr Create = CreateMatrix_String;
  static constexpr auto name = "Matrix_String";
  static constexpr auto fully_qualified_name = "fb.Matrix_String";
  static constexpr std::array<const char *, 2> field_names = {
    "size",
    "data"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
  static constexpr size_t fields_number = 2;
};

inline flatbuffers::Offset<Matrix_String> CreateMatrix_StringDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const fb::Delta *size = 0,
    const std::vector<flatbuffers::Offset<fb::Pair_Coord_String>> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<flatbuffers::Offset<fb::Pair_Coord_String>>(*data) : 0;
  return fb::CreateMatrix_String(
      _fbb,
      size,
      data__);
}

namespace OnOffState {

struct off FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef offBuilder Builder;
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return offTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct offBuilder {
  typedef off Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit offBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<off> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<off>(end);
    return o;
  }
};

inline flatbuffers::Offset<off> Createoff(
    flatbuffers::FlatBufferBuilder &_fbb) {
  offBuilder builder_(_fbb);
  return builder_.Finish();
}

struct off::Traits {
  using type = off;
  static auto constexpr Create = Createoff;
  static constexpr auto name = "off";
  static constexpr auto fully_qualified_name = "fb.OnOffState.off";
  static constexpr std::array<const char *, 0> field_names = {};
  static constexpr size_t fields_number = 0;
};

struct on FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef onBuilder Builder;
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return onTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_USER = 4
  };
  const flatbuffers::String *user() const {
    return GetPointer<const flatbuffers::String *>(VT_USER);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return user();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_USER) &&
           verifier.VerifyString(user()) &&
           verifier.EndTable();
  }
};

struct onBuilder {
  typedef on Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_user(flatbuffers::Offset<flatbuffers::String> user) {
    fbb_.AddOffset(on::VT_USER, user);
  }
  explicit onBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<on> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<on>(end);
    return o;
  }
};

inline flatbuffers::Offset<on> Createon(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> user = 0) {
  onBuilder builder_(_fbb);
  builder_.add_user(user);
  return builder_.Finish();
}

struct on::Traits {
  using type = on;
  static auto constexpr Create = Createon;
  static constexpr auto name = "on";
  static constexpr auto fully_qualified_name = "fb.OnOffState.on";
  static constexpr std::array<const char *, 1> field_names = {
    "user"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
  static constexpr size_t fields_number = 1;
};

inline flatbuffers::Offset<on> CreateonDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *user = nullptr) {
  auto user__ = user ? _fbb.CreateString(user) : 0;
  return fb::OnOffState::Createon(
      _fbb,
      user__);
}

struct switching_on FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef switching_onBuilder Builder;
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return switching_onTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PERCENT = 4
  };
  double percent() const {
    return GetField<double>(VT_PERCENT, 0.0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return percent();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_PERCENT) &&
           verifier.EndTable();
  }
};

struct switching_onBuilder {
  typedef switching_on Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_percent(double percent) {
    fbb_.AddElement<double>(switching_on::VT_PERCENT, percent, 0.0);
  }
  explicit switching_onBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<switching_on> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<switching_on>(end);
    return o;
  }
};

inline flatbuffers::Offset<switching_on> Createswitching_on(
    flatbuffers::FlatBufferBuilder &_fbb,
    double percent = 0.0) {
  switching_onBuilder builder_(_fbb);
  builder_.add_percent(percent);
  return builder_.Finish();
}

struct switching_on::Traits {
  using type = switching_on;
  static auto constexpr Create = Createswitching_on;
  static constexpr auto name = "switching_on";
  static constexpr auto fully_qualified_name = "fb.OnOffState.switching_on";
  static constexpr std::array<const char *, 1> field_names = {
    "percent"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
  static constexpr size_t fields_number = 1;
};

struct switching_off FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef switching_offBuilder Builder;
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return switching_offTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PERCENT = 4
  };
  double percent() const {
    return GetField<double>(VT_PERCENT, 0.0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return percent();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_PERCENT) &&
           verifier.EndTable();
  }
};

struct switching_offBuilder {
  typedef switching_off Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_percent(double percent) {
    fbb_.AddElement<double>(switching_off::VT_PERCENT, percent, 0.0);
  }
  explicit switching_offBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<switching_off> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<switching_off>(end);
    return o;
  }
};

inline flatbuffers::Offset<switching_off> Createswitching_off(
    flatbuffers::FlatBufferBuilder &_fbb,
    double percent = 0.0) {
  switching_offBuilder builder_(_fbb);
  builder_.add_percent(percent);
  return builder_.Finish();
}

struct switching_off::Traits {
  using type = switching_off;
  static auto constexpr Create = Createswitching_off;
  static constexpr auto name = "switching_off";
  static constexpr auto fully_qualified_name = "fb.OnOffState.switching_off";
  static constexpr std::array<const char *, 1> field_names = {
    "percent"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
  static constexpr size_t fields_number = 1;
};

}  // namespace OnOffState

struct OnOffState_t FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OnOffState_tBuilder Builder;
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return OnOffState_tTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OFF = 4,
    VT_ON = 6,
    VT_SWITCHING_ON = 8,
    VT_SWITCHING_OFF = 10
  };
  const fb::OnOffState::off *off() const {
    return GetPointer<const fb::OnOffState::off *>(VT_OFF);
  }
  const fb::OnOffState::on *on() const {
    return GetPointer<const fb::OnOffState::on *>(VT_ON);
  }
  const fb::OnOffState::switching_on *switching_on() const {
    return GetPointer<const fb::OnOffState::switching_on *>(VT_SWITCHING_ON);
  }
  const fb::OnOffState::switching_off *switching_off() const {
    return GetPointer<const fb::OnOffState::switching_off *>(VT_SWITCHING_OFF);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return off();
    else if constexpr (Index == 1) return on();
    else if constexpr (Index == 2) return switching_on();
    else if constexpr (Index == 3) return switching_off();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_OFF) &&
           verifier.VerifyTable(off()) &&
           VerifyOffset(verifier, VT_ON) &&
           verifier.VerifyTable(on()) &&
           VerifyOffset(verifier, VT_SWITCHING_ON) &&
           verifier.VerifyTable(switching_on()) &&
           VerifyOffset(verifier, VT_SWITCHING_OFF) &&
           verifier.VerifyTable(switching_off()) &&
           verifier.EndTable();
  }
};

struct OnOffState_tBuilder {
  typedef OnOffState_t Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_off(flatbuffers::Offset<fb::OnOffState::off> off) {
    fbb_.AddOffset(OnOffState_t::VT_OFF, off);
  }
  void add_on(flatbuffers::Offset<fb::OnOffState::on> on) {
    fbb_.AddOffset(OnOffState_t::VT_ON, on);
  }
  void add_switching_on(flatbuffers::Offset<fb::OnOffState::switching_on> switching_on) {
    fbb_.AddOffset(OnOffState_t::VT_SWITCHING_ON, switching_on);
  }
  void add_switching_off(flatbuffers::Offset<fb::OnOffState::switching_off> switching_off) {
    fbb_.AddOffset(OnOffState_t::VT_SWITCHING_OFF, switching_off);
  }
  explicit OnOffState_tBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<OnOffState_t> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OnOffState_t>(end);
    return o;
  }
};

inline flatbuffers::Offset<OnOffState_t> CreateOnOffState_t(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::OnOffState::off> off = 0,
    flatbuffers::Offset<fb::OnOffState::on> on = 0,
    flatbuffers::Offset<fb::OnOffState::switching_on> switching_on = 0,
    flatbuffers::Offset<fb::OnOffState::switching_off> switching_off = 0) {
  OnOffState_tBuilder builder_(_fbb);
  builder_.add_switching_off(switching_off);
  builder_.add_switching_on(switching_on);
  builder_.add_on(on);
  builder_.add_off(off);
  return builder_.Finish();
}

struct OnOffState_t::Traits {
  using type = OnOffState_t;
  static auto constexpr Create = CreateOnOffState_t;
  static constexpr auto name = "OnOffState_t";
  static constexpr auto fully_qualified_name = "fb.OnOffState_t";
  static constexpr std::array<const char *, 4> field_names = {
    "off",
    "on",
    "switching_on",
    "switching_off"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
  static constexpr size_t fields_number = 4;
};

struct OnOffFsm FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OnOffFsmBuilder Builder;
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return OnOffFsmTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STATE_STACK = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<fb::OnOffState_t>> *state_stack() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<fb::OnOffState_t>> *>(VT_STATE_STACK);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return state_stack();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_STATE_STACK) &&
           verifier.VerifyVector(state_stack()) &&
           verifier.VerifyVectorOfTables(state_stack()) &&
           verifier.EndTable();
  }
};

struct OnOffFsmBuilder {
  typedef OnOffFsm Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_state_stack(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fb::OnOffState_t>>> state_stack) {
    fbb_.AddOffset(OnOffFsm::VT_STATE_STACK, state_stack);
  }
  explicit OnOffFsmBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<OnOffFsm> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OnOffFsm>(end);
    return o;
  }
};

inline flatbuffers::Offset<OnOffFsm> CreateOnOffFsm(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fb::OnOffState_t>>> state_stack = 0) {
  OnOffFsmBuilder builder_(_fbb);
  builder_.add_state_stack(state_stack);
  return builder_.Finish();
}

struct OnOffFsm::Traits {
  using type = OnOffFsm;
  static auto constexpr Create = CreateOnOffFsm;
  static constexpr auto name = "OnOffFsm";
  static constexpr auto fully_qualified_name = "fb.OnOffFsm";
  static constexpr std::array<const char *, 1> field_names = {
    "state_stack"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
  static constexpr size_t fields_number = 1;
};

inline flatbuffers::Offset<OnOffFsm> CreateOnOffFsmDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<fb::OnOffState_t>> *state_stack = nullptr) {
  auto state_stack__ = state_stack ? _fbb.CreateVector<flatbuffers::Offset<fb::OnOffState_t>>(*state_stack) : 0;
  return fb::CreateOnOffFsm(
      _fbb,
      state_stack__);
}

struct Monster FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MonsterBuilder Builder;
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MonsterTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POS = 4,
    VT_MANA = 6,
    VT_HP = 8,
    VT_NAME = 10,
    VT_NONAME = 12,
    VT_NAMES = 14,
    VT_INVENTORY = 18,
    VT_COLOR = 20,
    VT_HAND = 22,
    VT_ELBOW = 24,
    VT_WEAPONS = 26,
    VT_PATH = 28,
    VT_PAIR1 = 30,
    VT_PAIR2 = 32,
    VT_MAP_VECS = 34,
    VT_MAP_STRS = 36,
    VT_MAP_WPNS = 38,
    VT_MYLIST = 40,
    VT_MYSET = 42,
    VT_OPT_INT1 = 44,
    VT_OPT_INT2 = 46,
    VT_OPT_INT3 = 48
  };
  const fb::Vec3 *pos() const {
    return GetStruct<const fb::Vec3 *>(VT_POS);
  }
  int16_t mana() const {
    return GetField<int16_t>(VT_MANA, 150);
  }
  int16_t hp() const {
    return GetField<int16_t>(VT_HP, 100);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *noname() const {
    return GetPointer<const flatbuffers::String *>(VT_NONAME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *names() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_NAMES);
  }
  const flatbuffers::Vector<uint8_t> *inventory() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_INVENTORY);
  }
  fb::e_color color() const {
    return static_cast<fb::e_color>(GetField<int8_t>(VT_COLOR, 2));
  }
  fb::e_hand hand() const {
    return static_cast<fb::e_hand>(GetField<int8_t>(VT_HAND, 0));
  }
  const fb::Weapon *elbow() const {
    return GetPointer<const fb::Weapon *>(VT_ELBOW);
  }
  const flatbuffers::Vector<flatbuffers::Offset<fb::Weapon>> *weapons() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<fb::Weapon>> *>(VT_WEAPONS);
  }
  const flatbuffers::Vector<const fb::Vec3 *> *path() const {
    return GetPointer<const flatbuffers::Vector<const fb::Vec3 *> *>(VT_PATH);
  }
  const fb::Pair_string_int *pair1() const {
    return GetPointer<const fb::Pair_string_int *>(VT_PAIR1);
  }
  const fb::Pair_Vec2_int *pair2() const {
    return GetStruct<const fb::Pair_Vec2_int *>(VT_PAIR2);
  }
  const flatbuffers::Vector<const fb::Pair_Vec2_int *> *map_vecs() const {
    return GetPointer<const flatbuffers::Vector<const fb::Pair_Vec2_int *> *>(VT_MAP_VECS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<fb::Pair_string_int>> *map_strs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<fb::Pair_string_int>> *>(VT_MAP_STRS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<fb::Pair_int_Weapon>> *map_wpns() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<fb::Pair_int_Weapon>> *>(VT_MAP_WPNS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *mylist() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_MYLIST);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *myset() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_MYSET);
  }
  const fb::Opt_int *opt_int1() const {
    return GetPointer<const fb::Opt_int *>(VT_OPT_INT1);
  }
  const fb::Opt_int *opt_int2() const {
    return GetPointer<const fb::Opt_int *>(VT_OPT_INT2);
  }
  const fb::Opt_int *opt_int3() const {
    return GetPointer<const fb::Opt_int *>(VT_OPT_INT3);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return pos();
    else if constexpr (Index == 1) return mana();
    else if constexpr (Index == 2) return hp();
    else if constexpr (Index == 3) return name();
    else if constexpr (Index == 4) return noname();
    else if constexpr (Index == 5) return names();
    else if constexpr (Index == 6) return inventory();
    else if constexpr (Index == 7) return color();
    else if constexpr (Index == 8) return hand();
    else if constexpr (Index == 9) return elbow();
    else if constexpr (Index == 10) return weapons();
    else if constexpr (Index == 11) return path();
    else if constexpr (Index == 12) return pair1();
    else if constexpr (Index == 13) return pair2();
    else if constexpr (Index == 14) return map_vecs();
    else if constexpr (Index == 15) return map_strs();
    else if constexpr (Index == 16) return map_wpns();
    else if constexpr (Index == 17) return mylist();
    else if constexpr (Index == 18) return myset();
    else if constexpr (Index == 19) return opt_int1();
    else if constexpr (Index == 20) return opt_int2();
    else if constexpr (Index == 21) return opt_int3();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<fb::Vec3>(verifier, VT_POS) &&
           VerifyField<int16_t>(verifier, VT_MANA) &&
           VerifyField<int16_t>(verifier, VT_HP) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_NONAME) &&
           verifier.VerifyString(noname()) &&
           VerifyOffset(verifier, VT_NAMES) &&
           verifier.VerifyVector(names()) &&
           verifier.VerifyVectorOfStrings(names()) &&
           VerifyOffset(verifier, VT_INVENTORY) &&
           verifier.VerifyVector(inventory()) &&
           VerifyField<int8_t>(verifier, VT_COLOR) &&
           VerifyField<int8_t>(verifier, VT_HAND) &&
           VerifyOffset(verifier, VT_ELBOW) &&
           verifier.VerifyTable(elbow()) &&
           VerifyOffset(verifier, VT_WEAPONS) &&
           verifier.VerifyVector(weapons()) &&
           verifier.VerifyVectorOfTables(weapons()) &&
           VerifyOffset(verifier, VT_PATH) &&
           verifier.VerifyVector(path()) &&
           VerifyOffset(verifier, VT_PAIR1) &&
           verifier.VerifyTable(pair1()) &&
           VerifyField<fb::Pair_Vec2_int>(verifier, VT_PAIR2) &&
           VerifyOffset(verifier, VT_MAP_VECS) &&
           verifier.VerifyVector(map_vecs()) &&
           VerifyOffset(verifier, VT_MAP_STRS) &&
           verifier.VerifyVector(map_strs()) &&
           verifier.VerifyVectorOfTables(map_strs()) &&
           VerifyOffset(verifier, VT_MAP_WPNS) &&
           verifier.VerifyVector(map_wpns()) &&
           verifier.VerifyVectorOfTables(map_wpns()) &&
           VerifyOffset(verifier, VT_MYLIST) &&
           verifier.VerifyVector(mylist()) &&
           verifier.VerifyVectorOfStrings(mylist()) &&
           VerifyOffset(verifier, VT_MYSET) &&
           verifier.VerifyVector(myset()) &&
           verifier.VerifyVectorOfStrings(myset()) &&
           VerifyOffset(verifier, VT_OPT_INT1) &&
           verifier.VerifyTable(opt_int1()) &&
           VerifyOffset(verifier, VT_OPT_INT2) &&
           verifier.VerifyTable(opt_int2()) &&
           VerifyOffset(verifier, VT_OPT_INT3) &&
           verifier.VerifyTable(opt_int3()) &&
           verifier.EndTable();
  }
};

struct MonsterBuilder {
  typedef Monster Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pos(const fb::Vec3 *pos) {
    fbb_.AddStruct(Monster::VT_POS, pos);
  }
  void add_mana(int16_t mana) {
    fbb_.AddElement<int16_t>(Monster::VT_MANA, mana, 150);
  }
  void add_hp(int16_t hp) {
    fbb_.AddElement<int16_t>(Monster::VT_HP, hp, 100);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Monster::VT_NAME, name);
  }
  void add_noname(flatbuffers::Offset<flatbuffers::String> noname) {
    fbb_.AddOffset(Monster::VT_NONAME, noname);
  }
  void add_names(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> names) {
    fbb_.AddOffset(Monster::VT_NAMES, names);
  }
  void add_inventory(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> inventory) {
    fbb_.AddOffset(Monster::VT_INVENTORY, inventory);
  }
  void add_color(fb::e_color color) {
    fbb_.AddElement<int8_t>(Monster::VT_COLOR, static_cast<int8_t>(color), 2);
  }
  void add_hand(fb::e_hand hand) {
    fbb_.AddElement<int8_t>(Monster::VT_HAND, static_cast<int8_t>(hand), 0);
  }
  void add_elbow(flatbuffers::Offset<fb::Weapon> elbow) {
    fbb_.AddOffset(Monster::VT_ELBOW, elbow);
  }
  void add_weapons(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fb::Weapon>>> weapons) {
    fbb_.AddOffset(Monster::VT_WEAPONS, weapons);
  }
  void add_path(flatbuffers::Offset<flatbuffers::Vector<const fb::Vec3 *>> path) {
    fbb_.AddOffset(Monster::VT_PATH, path);
  }
  void add_pair1(flatbuffers::Offset<fb::Pair_string_int> pair1) {
    fbb_.AddOffset(Monster::VT_PAIR1, pair1);
  }
  void add_pair2(const fb::Pair_Vec2_int *pair2) {
    fbb_.AddStruct(Monster::VT_PAIR2, pair2);
  }
  void add_map_vecs(flatbuffers::Offset<flatbuffers::Vector<const fb::Pair_Vec2_int *>> map_vecs) {
    fbb_.AddOffset(Monster::VT_MAP_VECS, map_vecs);
  }
  void add_map_strs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fb::Pair_string_int>>> map_strs) {
    fbb_.AddOffset(Monster::VT_MAP_STRS, map_strs);
  }
  void add_map_wpns(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fb::Pair_int_Weapon>>> map_wpns) {
    fbb_.AddOffset(Monster::VT_MAP_WPNS, map_wpns);
  }
  void add_mylist(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> mylist) {
    fbb_.AddOffset(Monster::VT_MYLIST, mylist);
  }
  void add_myset(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> myset) {
    fbb_.AddOffset(Monster::VT_MYSET, myset);
  }
  void add_opt_int1(flatbuffers::Offset<fb::Opt_int> opt_int1) {
    fbb_.AddOffset(Monster::VT_OPT_INT1, opt_int1);
  }
  void add_opt_int2(flatbuffers::Offset<fb::Opt_int> opt_int2) {
    fbb_.AddOffset(Monster::VT_OPT_INT2, opt_int2);
  }
  void add_opt_int3(flatbuffers::Offset<fb::Opt_int> opt_int3) {
    fbb_.AddOffset(Monster::VT_OPT_INT3, opt_int3);
  }
  explicit MonsterBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Monster> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Monster>(end);
    return o;
  }
};

inline flatbuffers::Offset<Monster> CreateMonster(
    flatbuffers::FlatBufferBuilder &_fbb,
    const fb::Vec3 *pos = 0,
    int16_t mana = 150,
    int16_t hp = 100,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> noname = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> names = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> inventory = 0,
    fb::e_color color = fb::e_color::blue,
    fb::e_hand hand = fb::e_hand::left,
    flatbuffers::Offset<fb::Weapon> elbow = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fb::Weapon>>> weapons = 0,
    flatbuffers::Offset<flatbuffers::Vector<const fb::Vec3 *>> path = 0,
    flatbuffers::Offset<fb::Pair_string_int> pair1 = 0,
    const fb::Pair_Vec2_int *pair2 = 0,
    flatbuffers::Offset<flatbuffers::Vector<const fb::Pair_Vec2_int *>> map_vecs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fb::Pair_string_int>>> map_strs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fb::Pair_int_Weapon>>> map_wpns = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> mylist = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> myset = 0,
    flatbuffers::Offset<fb::Opt_int> opt_int1 = 0,
    flatbuffers::Offset<fb::Opt_int> opt_int2 = 0,
    flatbuffers::Offset<fb::Opt_int> opt_int3 = 0) {
  MonsterBuilder builder_(_fbb);
  builder_.add_opt_int3(opt_int3);
  builder_.add_opt_int2(opt_int2);
  builder_.add_opt_int1(opt_int1);
  builder_.add_myset(myset);
  builder_.add_mylist(mylist);
  builder_.add_map_wpns(map_wpns);
  builder_.add_map_strs(map_strs);
  builder_.add_map_vecs(map_vecs);
  builder_.add_pair2(pair2);
  builder_.add_pair1(pair1);
  builder_.add_path(path);
  builder_.add_weapons(weapons);
  builder_.add_elbow(elbow);
  builder_.add_inventory(inventory);
  builder_.add_names(names);
  builder_.add_noname(noname);
  builder_.add_name(name);
  builder_.add_pos(pos);
  builder_.add_hp(hp);
  builder_.add_mana(mana);
  builder_.add_hand(hand);
  builder_.add_color(color);
  return builder_.Finish();
}

struct Monster::Traits {
  using type = Monster;
  static auto constexpr Create = CreateMonster;
  static constexpr auto name = "Monster";
  static constexpr auto fully_qualified_name = "fb.Monster";
  static constexpr std::array<const char *, 22> field_names = {
    "pos",
    "mana",
    "hp",
    "name",
    "noname",
    "names",
    "inventory",
    "color",
    "hand",
    "elbow",
    "weapons",
    "path",
    "pair1",
    "pair2",
    "map_vecs",
    "map_strs",
    "map_wpns",
    "mylist",
    "myset",
    "opt_int1",
    "opt_int2",
    "opt_int3"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
  static constexpr size_t fields_number = 22;
};

inline flatbuffers::Offset<Monster> CreateMonsterDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const fb::Vec3 *pos = 0,
    int16_t mana = 150,
    int16_t hp = 100,
    const char *name = nullptr,
    const char *noname = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *names = nullptr,
    const std::vector<uint8_t> *inventory = nullptr,
    fb::e_color color = fb::e_color::blue,
    fb::e_hand hand = fb::e_hand::left,
    flatbuffers::Offset<fb::Weapon> elbow = 0,
    const std::vector<flatbuffers::Offset<fb::Weapon>> *weapons = nullptr,
    const std::vector<fb::Vec3> *path = nullptr,
    flatbuffers::Offset<fb::Pair_string_int> pair1 = 0,
    const fb::Pair_Vec2_int *pair2 = 0,
    const std::vector<fb::Pair_Vec2_int> *map_vecs = nullptr,
    const std::vector<flatbuffers::Offset<fb::Pair_string_int>> *map_strs = nullptr,
    const std::vector<flatbuffers::Offset<fb::Pair_int_Weapon>> *map_wpns = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *mylist = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *myset = nullptr,
    flatbuffers::Offset<fb::Opt_int> opt_int1 = 0,
    flatbuffers::Offset<fb::Opt_int> opt_int2 = 0,
    flatbuffers::Offset<fb::Opt_int> opt_int3 = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto noname__ = noname ? _fbb.CreateString(noname) : 0;
  auto names__ = names ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*names) : 0;
  auto inventory__ = inventory ? _fbb.CreateVector<uint8_t>(*inventory) : 0;
  auto weapons__ = weapons ? _fbb.CreateVector<flatbuffers::Offset<fb::Weapon>>(*weapons) : 0;
  auto path__ = path ? _fbb.CreateVectorOfStructs<fb::Vec3>(*path) : 0;
  auto map_vecs__ = map_vecs ? _fbb.CreateVectorOfStructs<fb::Pair_Vec2_int>(*map_vecs) : 0;
  auto map_strs__ = map_strs ? _fbb.CreateVector<flatbuffers::Offset<fb::Pair_string_int>>(*map_strs) : 0;
  auto map_wpns__ = map_wpns ? _fbb.CreateVector<flatbuffers::Offset<fb::Pair_int_Weapon>>(*map_wpns) : 0;
  auto mylist__ = mylist ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*mylist) : 0;
  auto myset__ = myset ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*myset) : 0;
  return fb::CreateMonster(
      _fbb,
      pos,
      mana,
      hp,
      name__,
      noname__,
      names__,
      inventory__,
      color,
      hand,
      elbow,
      weapons__,
      path__,
      pair1,
      pair2,
      map_vecs__,
      map_strs__,
      map_wpns__,
      mylist__,
      myset__,
      opt_int1,
      opt_int2,
      opt_int3);
}

namespace MyVariant2 {

struct first FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef firstBuilder Builder;
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return firstTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_B = 6
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool b() const {
    return GetField<uint8_t>(VT_B, 0) != 0;
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return name();
    else if constexpr (Index == 1) return b();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint8_t>(verifier, VT_B) &&
           verifier.EndTable();
  }
};

struct firstBuilder {
  typedef first Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(first::VT_NAME, name);
  }
  void add_b(bool b) {
    fbb_.AddElement<uint8_t>(first::VT_B, static_cast<uint8_t>(b), 0);
  }
  explicit firstBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<first> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<first>(end);
    return o;
  }
};

inline flatbuffers::Offset<first> Createfirst(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    bool b = false) {
  firstBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_b(b);
  return builder_.Finish();
}

struct first::Traits {
  using type = first;
  static auto constexpr Create = Createfirst;
  static constexpr auto name = "first";
  static constexpr auto fully_qualified_name = "fb.MyVariant2.first";
  static constexpr std::array<const char *, 2> field_names = {
    "name",
    "b"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
  static constexpr size_t fields_number = 2;
};

inline flatbuffers::Offset<first> CreatefirstDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    bool b = false) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return fb::MyVariant2::Createfirst(
      _fbb,
      name__,
      b);
}

struct second FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef secondBuilder Builder;
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return secondTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FLAG1 = 4,
    VT_FLAG2 = 6
  };
  bool flag1() const {
    return GetField<uint8_t>(VT_FLAG1, 0) != 0;
  }
  bool flag2() const {
    return GetField<uint8_t>(VT_FLAG2, 0) != 0;
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return flag1();
    else if constexpr (Index == 1) return flag2();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_FLAG1) &&
           VerifyField<uint8_t>(verifier, VT_FLAG2) &&
           verifier.EndTable();
  }
};

struct secondBuilder {
  typedef second Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_flag1(bool flag1) {
    fbb_.AddElement<uint8_t>(second::VT_FLAG1, static_cast<uint8_t>(flag1), 0);
  }
  void add_flag2(bool flag2) {
    fbb_.AddElement<uint8_t>(second::VT_FLAG2, static_cast<uint8_t>(flag2), 0);
  }
  explicit secondBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<second> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<second>(end);
    return o;
  }
};

inline flatbuffers::Offset<second> Createsecond(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool flag1 = false,
    bool flag2 = false) {
  secondBuilder builder_(_fbb);
  builder_.add_flag2(flag2);
  builder_.add_flag1(flag1);
  return builder_.Finish();
}

struct second::Traits {
  using type = second;
  static auto constexpr Create = Createsecond;
  static constexpr auto name = "second";
  static constexpr auto fully_qualified_name = "fb.MyVariant2.second";
  static constexpr std::array<const char *, 2> field_names = {
    "flag1",
    "flag2"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
  static constexpr size_t fields_number = 2;
};

struct third FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef thirdBuilder Builder;
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return thirdTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COST = 4
  };
  int32_t cost() const {
    return GetField<int32_t>(VT_COST, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return cost();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_COST) &&
           verifier.EndTable();
  }
};

struct thirdBuilder {
  typedef third Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_cost(int32_t cost) {
    fbb_.AddElement<int32_t>(third::VT_COST, cost, 0);
  }
  explicit thirdBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<third> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<third>(end);
    return o;
  }
};

inline flatbuffers::Offset<third> Createthird(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t cost = 0) {
  thirdBuilder builder_(_fbb);
  builder_.add_cost(cost);
  return builder_.Finish();
}

struct third::Traits {
  using type = third;
  static auto constexpr Create = Createthird;
  static constexpr auto name = "third";
  static constexpr auto fully_qualified_name = "fb.MyVariant2.third";
  static constexpr std::array<const char *, 1> field_names = {
    "cost"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
  static constexpr size_t fields_number = 1;
};

}  // namespace MyVariant2

struct MyVariant2_t FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MyVariant2_tBuilder Builder;
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MyVariant2_tTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FIRST = 4,
    VT_SECOND = 6,
    VT_THIRD = 8
  };
  const fb::MyVariant2::first *first() const {
    return GetPointer<const fb::MyVariant2::first *>(VT_FIRST);
  }
  const fb::MyVariant2::second *second() const {
    return GetPointer<const fb::MyVariant2::second *>(VT_SECOND);
  }
  const fb::MyVariant2::third *third() const {
    return GetPointer<const fb::MyVariant2::third *>(VT_THIRD);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return first();
    else if constexpr (Index == 1) return second();
    else if constexpr (Index == 2) return third();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FIRST) &&
           verifier.VerifyTable(first()) &&
           VerifyOffset(verifier, VT_SECOND) &&
           verifier.VerifyTable(second()) &&
           VerifyOffset(verifier, VT_THIRD) &&
           verifier.VerifyTable(third()) &&
           verifier.EndTable();
  }
};

struct MyVariant2_tBuilder {
  typedef MyVariant2_t Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_first(flatbuffers::Offset<fb::MyVariant2::first> first) {
    fbb_.AddOffset(MyVariant2_t::VT_FIRST, first);
  }
  void add_second(flatbuffers::Offset<fb::MyVariant2::second> second) {
    fbb_.AddOffset(MyVariant2_t::VT_SECOND, second);
  }
  void add_third(flatbuffers::Offset<fb::MyVariant2::third> third) {
    fbb_.AddOffset(MyVariant2_t::VT_THIRD, third);
  }
  explicit MyVariant2_tBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MyVariant2_t> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MyVariant2_t>(end);
    return o;
  }
};

inline flatbuffers::Offset<MyVariant2_t> CreateMyVariant2_t(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MyVariant2::first> first = 0,
    flatbuffers::Offset<fb::MyVariant2::second> second = 0,
    flatbuffers::Offset<fb::MyVariant2::third> third = 0) {
  MyVariant2_tBuilder builder_(_fbb);
  builder_.add_third(third);
  builder_.add_second(second);
  builder_.add_first(first);
  return builder_.Finish();
}

struct MyVariant2_t::Traits {
  using type = MyVariant2_t;
  static auto constexpr Create = CreateMyVariant2_t;
  static constexpr auto name = "MyVariant2_t";
  static constexpr auto fully_qualified_name = "fb.MyVariant2_t";
  static constexpr std::array<const char *, 3> field_names = {
    "first",
    "second",
    "third"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
  static constexpr size_t fields_number = 3;
};

namespace MySumtype {

}  // namespace MySumtype

namespace OnOffState {

}  // namespace OnOffState

namespace MyVariant2 {

}  // namespace MyVariant2

inline const flatbuffers::TypeTable *e_handTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    fb::e_handTypeTable
  };
  static const char * const names[] = {
    "left",
    "right"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *e_colorTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    fb::e_colorTypeTable
  };
  static const char * const names[] = {
    "red",
    "green",
    "blue"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

namespace MySumtype {

inline const flatbuffers::TypeTable *noneTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *someTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const char * const names[] = {
    "s",
    "y"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *moreTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_DOUBLE, 0, -1 }
  };
  static const char * const names[] = {
    "d"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

}  // namespace MySumtype

inline const flatbuffers::TypeTable *MySumtype_tTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    fb::MySumtype::noneTypeTable,
    fb::MySumtype::someTypeTable,
    fb::MySumtype::moreTypeTable
  };
  static const char * const names[] = {
    "none",
    "some",
    "more"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *WeaponTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_SHORT, 0, -1 }
  };
  static const char * const names[] = {
    "name",
    "damage"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Vec2TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const int64_t values[] = { 0, 4, 8 };
  static const char * const names[] = {
    "x",
    "y"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_STRUCT, 2, type_codes, nullptr, nullptr, values, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Vec3TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const int64_t values[] = { 0, 4, 8, 12 };
  static const char * const names[] = {
    "x",
    "y",
    "z"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_STRUCT, 3, type_codes, nullptr, nullptr, values, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Pair_Vec2_intTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    fb::Vec2TypeTable
  };
  static const int64_t values[] = { 0, 8, 12 };
  static const char * const names[] = {
    "fst",
    "snd"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_STRUCT, 2, type_codes, type_refs, nullptr, values, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Pair_int_WeaponTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    fb::WeaponTypeTable
  };
  static const char * const names[] = {
    "fst",
    "snd"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SetTesterTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 1, -1 }
  };
  static const char * const names[] = {
    "set"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MapTester1TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    fb::Pair_string_intTypeTable
  };
  static const char * const names[] = {
    "map"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MapTester2TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    fb::Pair_int_intTypeTable
  };
  static const char * const names[] = {
    "map"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *EmptyTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MyVariantTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_CHAR, 0, 2 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    fb::Vec2TypeTable,
    fb::WeaponTypeTable,
    fb::e_colorTypeTable
  };
  static const char * const names[] = {
    "active_index",
    "one",
    "two",
    "three",
    "four"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MyVariantNoIndexTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    fb::Vec2TypeTable,
    fb::WeaponTypeTable
  };
  static const char * const names[] = {
    "two",
    "three",
    "four"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MyFloatVariantTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const char * const names[] = {
    "active_index",
    "one",
    "two",
    "three",
    "four"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 5, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MyFlatQueuesTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_STRING, 1, -1 },
    { flatbuffers::ET_INT, 1, -1 }
  };
  static const char * const names[] = {
    "q1",
    "q2",
    "dq"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Pair_Coord_StringTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    fb::CoordTypeTable
  };
  static const char * const names[] = {
    "fst",
    "snd"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Matrix_StringTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 1, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    fb::DeltaTypeTable,
    fb::Pair_Coord_StringTypeTable
  };
  static const char * const names[] = {
    "size",
    "data"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

namespace OnOffState {

inline const flatbuffers::TypeTable *offTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *onTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "user"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *switching_onTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_DOUBLE, 0, -1 }
  };
  static const char * const names[] = {
    "percent"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *switching_offTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_DOUBLE, 0, -1 }
  };
  static const char * const names[] = {
    "percent"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

}  // namespace OnOffState

inline const flatbuffers::TypeTable *OnOffState_tTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 },
    { flatbuffers::ET_SEQUENCE, 0, 3 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    fb::OnOffState::offTypeTable,
    fb::OnOffState::onTypeTable,
    fb::OnOffState::switching_onTypeTable,
    fb::OnOffState::switching_offTypeTable
  };
  static const char * const names[] = {
    "off",
    "on",
    "switching_on",
    "switching_off"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *OnOffFsmTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    fb::OnOffState_tTypeTable
  };
  static const char * const names[] = {
    "state_stack"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MonsterTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SHORT, 0, -1 },
    { flatbuffers::ET_SHORT, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 1, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_UCHAR, 1, -1 },
    { flatbuffers::ET_CHAR, 0, 1 },
    { flatbuffers::ET_CHAR, 0, 2 },
    { flatbuffers::ET_SEQUENCE, 0, 3 },
    { flatbuffers::ET_SEQUENCE, 1, 3 },
    { flatbuffers::ET_SEQUENCE, 1, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 4 },
    { flatbuffers::ET_SEQUENCE, 0, 5 },
    { flatbuffers::ET_SEQUENCE, 1, 5 },
    { flatbuffers::ET_SEQUENCE, 1, 4 },
    { flatbuffers::ET_SEQUENCE, 1, 6 },
    { flatbuffers::ET_STRING, 1, -1 },
    { flatbuffers::ET_STRING, 1, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 7 },
    { flatbuffers::ET_SEQUENCE, 0, 7 },
    { flatbuffers::ET_SEQUENCE, 0, 7 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    fb::Vec3TypeTable,
    fb::e_colorTypeTable,
    fb::e_handTypeTable,
    fb::WeaponTypeTable,
    fb::Pair_string_intTypeTable,
    fb::Pair_Vec2_intTypeTable,
    fb::Pair_int_WeaponTypeTable,
    fb::Opt_intTypeTable
  };
  static const char * const names[] = {
    "pos",
    "mana",
    "hp",
    "name",
    "noname",
    "names",
    "friendly",
    "inventory",
    "color",
    "hand",
    "elbow",
    "weapons",
    "path",
    "pair1",
    "pair2",
    "map_vecs",
    "map_strs",
    "map_wpns",
    "mylist",
    "myset",
    "opt_int1",
    "opt_int2",
    "opt_int3"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 23, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

namespace MyVariant2 {

inline const flatbuffers::TypeTable *firstTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const char * const names[] = {
    "name",
    "b"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *secondTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const char * const names[] = {
    "flag1",
    "flag2"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *thirdTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const char * const names[] = {
    "cost"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

}  // namespace MyVariant2

inline const flatbuffers::TypeTable *MyVariant2_tTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    fb::MyVariant2::firstTypeTable,
    fb::MyVariant2::secondTypeTable,
    fb::MyVariant2::thirdTypeTable
  };
  static const char * const names[] = {
    "first",
    "second",
    "third"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

}  // namespace fb

#endif  // FLATBUFFERS_GENERATED_TESTING_FB_H_
