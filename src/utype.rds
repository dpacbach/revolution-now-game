# ===============================================================
# utype.rds
#
# Project: Revolution Now
#
# Created by dsicilia on 2021-02-28.
#
# Description: RDS definitions for the utype module.
#
# ===============================================================
include [
  # rn
  commodity.hpp
  coord.hpp
  enum-map.hpp
  mv-points.hpp
  tiles.hpp

  # base
  base/maybe.hpp

  # C++ standard library.
  <string>
  <unordered_map>
  <unordered_set>
]

namespace rn {

enum e_unit_type [
  # Basic colonists.
  petty_criminal,
  indentured_servant,
  free_colonist,

  # Non-expert colonist with modifiers.
  soldier,
  dragoon,
  pioneer,
  missionary,
  scout,

  # Expert colonists.
  expert_farmer,
  expert_fisherman,
  expert_sugar_planter,
  expert_tobacco_planter,
  expert_cotton_planter,
  expert_fur_trapper,
  expert_lumberjack,
  expert_ore_miner,
  expert_silver_miner,
  master_carpenter,
  master_rum_distiller,
  master_tobacconist,
  master_weaver,
  master_fur_trader,
  master_blacksmith,
  master_gunsmith,
  elder_statesman,
  firebrand_preacher,
  hardy_colonist,
  jesuit_colonist,
  seasoned_colonist,
  veteran_colonist,

  # Expert colonist with modifier.
  veteran_soldier,
  veteran_dragoon,
  continental_army,
  continental_cavalry,
  regular,
  cavalry,
  hardy_pioneer,
  jesuit_missionary,
  seasoned_scout,

  # Non-human combat units.
  artillery,
  damaged_artillery,

  # Ships.
  caravel,
  merchantman,
  galleon,
  privateer,
  frigate,
  man_o_war,

  # Land transport.
  wagon_train,

  # Treasure.
  small_treasure,
  large_treasure,
]

enum e_unit_human [
  no,
  yes,
  from_base,
]

enum e_unit_type_modifier [
  blessing,
  horses,
  muskets,
  tools,
  independence,
  strength,
]

enum e_unit_inventory [
  gold,
  tools,
]

struct UnitInventoryTraits {
  commodity:        'base::maybe<e_commodity>'
  min_quantity:     int
  max_quantity:     int
  multiple:         int
  default_quantity: int

  _features: [equality, validation]
}

sumtype ModifierAssociation {
  # There is no association between the modifier and any com-
  # modity or inventory item.
  none {}
  # Granting the modifier to a unit will consume a fixed amount
  # of a given commodity.
  commodity {
    commodity: Commodity
  }
  # Granting the modifier to a unit will require a certain amount
  # of the given commodity in the inventory. That inventory item
  # may or may not be associated with a commodity. Either way,
  # the inventory traits will give constraints on the allowed
  # quantities of this inventory type.
  inventory {
    type: e_unit_inventory
  }
}

struct UnitTypeModifierTraits {
  player_can_grant: bool
  association:      ModifierAssociation_t
}

# This is used to represent two different things:
#
#   1. The activity that a unit is currently engaged in, regard-
#      less of its type.
#   2. The expertise that a unit has.
#
enum e_unit_activity [
  # Raw commodities.
  farming,
  fishing,
  sugar_planting,
  tobacco_planting,
  cotton_planting,
  fur_trapping,
  lumberjacking,
  ore_mining,
  silver_mining,

  # Production.
  carpentry,
  rum_distilling,
  tobacconistry,
  weaving,
  fur_trading,
  blacksmithing,
  gunsmithing,

  # External to colony.
  fighting,
  pioneering,
  scouting,
  missioning,

  # Misc.
  bell_ringing,
  preaching,
]

sumtype UnitDeathAction {
  destroy {}
  capture {}
  naval {}
  demote {
    lose: 'std::unordered_set<e_unit_type_modifier>'
  }
}

# Unit promotion. Only base types can be promoted, but the de-
# rived type can sometimes inform how that happens. So both base
# types and derived types can have this attribute, but some al-
# ternatives are only allowed for one or the other.
sumtype UnitPromotion {
  # For base types. The unit type always changes to a fixed type.
  fixed {
    type: e_unit_type
  }
  # For base types. The unit gains some expertise dictated by the
  # occupation that it is currently assuming.
  #
  # Examples:
  #
  #   * If a free colonist is planting cotton then it will be
  #     promoted to an expert cotton planter.
  #   * If a free colonist is studying carpentry then it will be-
  #     come a carpenter.
  #   * If a free colonist becomes a scout and wins a battle then
  #     it will be promoted to seasoned scout (not veteran sol-
  #     dier). So when a unit is assuming a derived type, the
  #     "occupation" is determined by the type of occupation of
  #     the derived type and not what the unit is immediately en-
  #     gaged in.
  #   * If a free colonist set as a pioneer wins a battle, it
  #     will become a hardy pioneer.
  #
  occupation {}
  # For derived types. The unit type provides expertise that will
  # be given to a base type if it has the `occupation` promotion
  # flag. If the base type has the `fixed` promotion flag then
  # that will be respected. If the base type has no promotion
  # flag then no promotion will happen. An example of the latter
  # is if an expert farmer is made into a scout and then experi-
  # ences a promotion event; in that case nothing will happen.
  expertise {
    kind: e_unit_activity
  }
  # This one is allowed for either base types or derived types,
  # but in practice it is only used for derived types in the de-
  # fault game rules. A unit type with the `modifier` promotion
  # flag will gain the modifier upon promotion. For example, a
  # veteran dragoon that wins a battle after independence is de-
  # clared might be promoted to a continental cavalry. If the
  # base type cannot accept the modifier then no promotion hap-
  # pens.
  modifier {
    kind: e_unit_type_modifier
  }
}

# Describes a literal unit type without regard to the concept of
# base or derived type.
struct UnitTypeAttributes {
  type: e_unit_type

  name: 'std::string'

  # Rendering
  tile: e_tile
  nat_icon_front: bool
  nat_icon_position: e_direction

  # Movement
  ship: bool
  visibility: int
  movement_points: MvPoints

  # Combat
  attack_points: int
  defense_points: int

  # Cargo
  cargo_slots: int
  # Slots occupied by this unit.
  cargo_slots_occupies: 'base::maybe<int>'

  on_death: UnitDeathAction_t

  # Describes if/how this unit is a human. This is important to
  # know so that we can e.g. ensure that only human units can
  # found colonies. Derived types must always have "from_base"
  # for this field, meaning that the human status will be in-
  # ferred from the base type, which it kind of has to be because
  # in theory there could be multiple pathways to derive a single
  # unit and so there (again, theoretically) wouldn't be a
  # well-defined value for this field for a derived type. For a
  # base type, it can be either "yes" or "no".
  human: e_unit_human

  # If this is a derived unit type then it must specify a canon-
  # ical base type that will be used to construct it when none is
  # specified. In some cases there is only one allowed base type
  # (e.g. a veteran dragoon must have a veteran colonist as its
  # base type) in which case it must hold that value.
  canonical_base: 'base::maybe<e_unit_type>'

  # If this unit type has an expertise. This is only for some
  # base types.
  expertise: 'base::maybe<e_unit_activity>'

  # Describes how this unit (can be either base or derived) han-
  # dles the clearing of its specialty. If it is a base type then
  # this can be either null (cannot clear) or a unit type. For
  # derived types, this can be either null (meaning consult the
  # base type) or a unit type. See the `cleared_expertise` func-
  # tion below for more info on the precise logic used.
  cleared_expertise: 'base::maybe<e_unit_type>'

  # Determines how the unit gets promoted or how the unit influ-
  # ences promotion of a base type. See sumtype comments to ex-
  # planation of the meaning of the variant alternatives.
  promotion: 'base::maybe<UnitPromotion_t>'

  # Tells us how to convert a base unit type into another in re-
  # sponse to the gain of some modifiers, e.g. when a
  # free_colonist is given horses, what unit type does it become?
  # Only base unit types can have this.
  modifiers: 'std::unordered_map<e_unit_type, std::unordered_set<e_unit_type_modifier>>'

  # This gives a list of all of the inventory types that the unit
  # is required to have. Moreover, the unit cannot hold any in-
  # ventory types that are not in this list. For consistency, if
  # a certain inventory type has a modifier association then: 1)
  # no base type can have that inventory type, and 2) derived
  # types that have that inventory type must have the associated
  # modifier along all possible paths to the derived unit (from
  # all relevant base types).
  inventory_types: 'std::unordered_set<e_unit_inventory>'

  # Can this unit type be obtained from a base type plus some
  # modifiers?
  is_derived: bool
}

# The constituents of this struct need to be validated together.
struct UnitCompositionConfig {
  # TODO: when adding validate methods, need to ensure that the
  # maps have non-default-constructed values for all keys, since
  # the enum map no longer does that upon deserialization.
  inventory_traits: 'ExhaustiveEnumMap<e_unit_inventory, UnitInventoryTraits>'
  modifier_traits:  'ExhaustiveEnumMap<e_unit_type_modifier, UnitTypeModifierTraits>'
  unit_types:       'ExhaustiveEnumMap<e_unit_type, UnitTypeAttributes>'

  _features: [equality, validation]
}

namespace wrapped {

struct UnitType {
  base_type: e_unit_type
  type:      e_unit_type

  _features: [equality, validation]
}

} #

} # namespace rn