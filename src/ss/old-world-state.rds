# ===============================================================
# old-world-state.rds
#
# Project: Revolution Now
#
# Created by dsicilia on 2022-05-27.
#
# Description: Per-player old world state.
#
# ===============================================================
# gs
include "ss/market.rds.hpp"
include "ss/unit-id.hpp"
include "ss/unit-type.rds.hpp"

# base
include "base/maybe.hpp"

# C++ standard library
include "<array>"

namespace "rn"

# How many of each unit the king has added into his expeditionary
# force. These will grow as the game progresses.
struct.ExpeditionaryForce {
  regulars   'int',
  cavalry    'int',
  artillery  'int',
  men_of_war 'int',

  _features { equality, validation }
}

# The state of the harbor view UI.
struct.HarborState {
  # TODO: should add validation that this unit exists.
  selected_unit 'base::maybe<UnitId>',
}

# The state of things related to immigration on the europe side.
struct.ImmigrationState {
  # At any given time there are three immigrants in the pool who
  # are considering to come. Note that one or more of these three
  # unit types can be the same type. The unit types must be human
  # types (no ships, no artillery, no wagon trains, etc.) and
  # must be non-revolutionary types.
  immigrants_pool 'std::array<e_unit_type, 3>',

  # This is NOT the exact cost of recruiting the next immigrant,
  # it is just a base value which must be added to the (normally
  # calculated) cost. The reason for this is that the cost of an
  # immigrant cannot be computed simply from the instantaneous
  # values of the usual inputs (i.e., current number of crosses,
  # current number units, current number of units on dock, etc.)
  # because it must increase each time the player pays the re-
  # cruitment cost, at least until the next immigration that is
  # earned through crosses. Once the next immigration happens
  # that is earned through cross accumulation (alone) then this
  # value gets reset to zero. This seems to be the way the orig-
  # inal game works (increasing this by 20 per recruitment) prob-
  # ably to make it more difficult to just recruit a large number
  # of immigrants at once.
  next_recruit_cost_base 'int',

  _features { equality, validation }
}

# State of the current tax rate and movement thereof.
struct.TaxationState {
  # Tax rate (%) imposed by the king: [0, 100].
  tax_rate 'int',

  _features { equality, validation }
}

# This holds the state of old-world related things. That
# includes:
#
#   * The harbor UI state.
#   * The state of the king and parent country.
#   * The prices of commodities in the old world.
#   * The size of the expeditionary force.
#
# It is not a
# top-level state because there is one for each player, so it is
# more natural to just embed it in the Player object. That said,
# it is also nice to have it in its own struct grouping.
struct.OldWorldState {
  harbor_state 'HarborState',

  # At any given time there are three immigrants in the pool who
  # are considering to come.
  immigration 'ImmigrationState',

  # All things taxes.
  taxes 'TaxationState',

  # Player-specific market state.
  market 'PlayerMarketState',

  # Royal expeditionary force.
  expeditionary_force 'ExpeditionaryForce',
}
