# ===============================================================
# market.rds
#
# Project: Revolution Now
#
# Created by dsicilia on 2022-08-23.
#
# Description: Rds definitions for the ss/market module.
#
# ===============================================================
# ss
include "ss/commodity.rds.hpp"

# refl
include "refl/enum-map.hpp"

namespace "rn"

# In the OG the bid/ask spread is fixed for each commodity. That
# is the reason that we don't have the ask prices here, since
# those can always be derived from the bid price.
struct.MarketItem {
  # This is the price that this commodity started off at; it will
  # have some amount of randomness. This value is needed because
  # it provides a reference point from which to apply the net
  # supply delta to compute the current price, though it is only
  # needed in the default price model.
  starting_bid_price_in_hundreds 'int',

  # Net traded volume in europe. Starts off as zero, then in-
  # creases (decreases) each time a commodity is sold (bought).
  # The way it is used depends on the price model. Note that this
  # is not in hundreds but in individual units, which is impor-
  # tant because the player can buy/sell in any quantity.
  net_traded_volume 'int',

  # The price group model also requires a separate (intrinsic)
  # volume that is not directly changed by buying selling. This
  # is only relevant for the commodities in the price groups.
  intrinsic_volume 'int',

  # This is the current bid price and the one that will always be
  # shown to the player and the one to be used to make transac-
  # tions (though upon making a transaction it could be adjusted
  # immediately thereafter).
  #
  # This has to be stored separately since in general it cannot
  # be derived from the state of the price model at any given
  # time, since the game has a rule where the price can only move
  # one unit per turn. And also we need to what the previous
  # price was each turn so that we can know when to notify the
  # player about changes to it.
  #
  # The idea is that we use one of the models to compute a target
  # price each turn, and then we increment or decrement this cur-
  # rent price until it hits the target (moving target).
  current_bid_price_in_hundreds 'int',

  # Is there an active boycott on this commodity.
  boycott 'bool',

  _features { equality, validation }
}

struct.MarketState {
  # This holds data representing the market state for each com-
  # modity, but does not apply for rum, cigars, cloth, and coats,
  # since they have a separate model.
  commodities 'refl::enum_map<e_commodity, MarketItem>',
}
