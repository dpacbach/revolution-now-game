# ===============================================================
# vertex.rds
#
# Project: Revolution Now
#
# Created by dsicilia on 2022-03-07.
#
# Description: Rds definitions for the vertex module.
#
# ===============================================================
# gl
include "gl/attribs.hpp"

namespace "rr"

struct.GenericVertex {
  # The type of object that this vertex is a part of.  Possible
  # value are:
  #
  #  0. Sprite. This triangle will be filled in with a sprite
  #     from the texture atlas as-is.
  #
  #  1. Solid rectangle. This triangle will be filled in with a
  #     solid color.
  #
  #  2. Silhouette. This triangle will be contain a sprite copied
  #     from the texture atlas, but all of its non-transparent
  #     pixels will be replaced by a fixed color. Examples of
  #     uses for this would be fonts and window shadows.
  #
  #  3. Stencil. This triangle is a sprite that will be drawn as
  #     such (respecting transparency), but all pixels in the
  #     sprite that are a key color will be replaced by pixels of
  #     an alternate sprite (specified in the atlas via the
  #     atlas_target_offset) with alpha multiplication.
  #
  #  The above options should be in order of decreasing probabil-
  #  ity, that way most shaders can return early most of the time
  #  and won't spend time testing for unlikely branches.
  type 'int32_t',

  # bool. If this is zero then the vertex will be discarded. This
  # can be used e.g. for unit blinking animations.
  visible 'int32_t',

  # Depixelation. This triangle will have individual pixels ran-
  # domly removed depending on the stage of the animation, which
  # is given by the z value of this parameter, and the inversion
  # flag which is given by the w. If inversion is false then
  # stage=0 means no depixelation and 1.0 means full depixela-
  # tion. If the inversion flat is true then the interpretation
  # of the stage is flipped so that stage=0 means full depixela-
  # tion and stage=1.0 means no depixelation. Note that inver-
  # sion=true is not the same as doing stage=1.0-stage, and that
  # is because the set of pixels e.g. in the range [0,.1] is dif-
  # ferent from those in [.9,1]. So you use the inversion flag
  # when you want to invert the stage of each pixel in the anima-
  # tion. This used to implement the depixelation of one image to
  # another; the source will have its stage move from 0->1 with
  # inversion=false, and the target image will have its stage
  # move also from 0->1 but with inversion=true. That way, each
  # time a pixel is removed from the source image, that same
  # pixel will be added to the target image.
  #
  # We need to make sure that the depixelation animation gets
  # rendered correctly even as the square being depixelated moves
  # around on screen. That is a challenge because the depixela-
  # tion is governed by hashing the screen coordinate. To support
  # this we use the xy coordinates of this vector.
  #
  # The xy component specifies a reference point which is a
  # screen/game coordinate that moves with the square being ren-
  # dered, such that the distance between this coordinate a given
  # vertex on the square remains fixed even as that square moves
  # around on screen. For example, this could be the screen coor-
  # dinate of the upper left corner of the sprite being depixe-
  # lated. This is used in the depixelation hashing algorithm to
  # make the hashing values independent of where the square is
  # located on screen. This way, if something is depixelating,
  # the animation proceeds properly even if the square is simul-
  # taneously moving. It can be an arbitrary position relative to
  # the square, but it would usually be the upper left corner.
  #
  # This is a flat vertex attribute, meaning that it must be the
  # same for all vertices in the square.
  depixelate 'gl::vec4',

  # Position of the vertex in game coordinates, i.e. where one
  # unit corresponds to one logical pixel and where the origin is
  # at the upper left of the screen and y increases downward.
  position 'gl::vec2',

  # For triangles that get filled in with a texture, this will be
  # the coordinates of the vertex in the texture atlas.
  atlas_position 'gl::vec2',

  # This is a flat vertex that will be populated when a sprite is
  # rendered from the atlas and will contain the atlas position
  # of the center of the sprite. This is used for helping to cor-
  # rect for rounding errors when reading from the atlas that
  # would otherwise cause visual artifacts.
  atlas_center 'gl::vec2',

  # For stencil types this points to the alternate texture in the
  # atlas that will be used for pixels of the key color.
  atlas_target_offset 'gl::vec2',

  # For solid triangles or silhouettes this will be the color
  # used. Components should be in [0, 1.0]. For silhouettes,
  # alpha in this color will be multiplied by the alpha of the
  # texture pixel.
  #
  # For stencils this will be the key color.
  fixed_color 'gl::color',

  # The final pixel color will have its alpha multiplied by this
  # value (no matter how it was produced). Should be in [0, 1].
  alpha_multiplier 'float',

  # This is a rescaling; the `position` attribute will be multi-
  # plied by this value. A value of 1.0 is a no-op.
  scaling 'float',

  # This is a translation; the `position` attribute will be added
  # to this value after scaling. A value of 0.0 is a no-op.
  translation 'gl::vec2',

  # When this is zero color cycling is off. When it is non-zero
  # then color cycling is on, and the cycling animation stage
  # will be taken from the corresponding uniform.
  color_cycle 'int32_t',

  # This is a boolean which, when true, will subject the vertices
  # to the "camera" uniform, which means translation of position
  # and zoom, in the vertex shader. This is different from the
  # `translation` and `scale` attributes above in that those
  # allow different values per vertex. If both the camera is en-
  # abled and the per-vertex scale/translation are specified,
  # then the latter is applied first, then the former.
  use_camera 'int32_t',

  # Need this in all vertex structs since OpenGL needs to have
  # the offsets of each member of the struct.
  _features { equality, offsets }
}
