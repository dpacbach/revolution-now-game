# ===============================================================
# TODO
# ===============================================================

  1.  Implement road and irrigation rendering.
  2.  Implement roads and irrigation building.
  3.  Implement terrain type rendering.
  4.  Implement world generation.
  5.  Implement terrain visibility.
  6.  Draw remainder of unit types.
  7.  Implement colony land production.
  8.  Implement selecting colonist profession in colony view.
  9.  Implement mini map.
  10. Implement stats in panel.
  11. Implement gold.
  12. Implement old world prices and price changes.
  13. Allow purchases things from old world.
  14. Implement that immigrants appear on the doc.
  15. Create colony building art.
  16. Render colony buildings in colony.
  17. Implement colony building workers.
  18. Implement colony production (from lumber/tools).
  19. Implement wagon train trade routes.

# ===============================================================
# OpenGL
# ===============================================================

  1. See doc/gl-perf-notes.txt. Need to implement reusable
     buffers so that we don't have to recreate the land-view
     buffer each frame. There are two choices: 1) we can upload
     the buffer to GPU memory and modify it with GPU commands.
     This may work despite the high latency (~100 buffer updates
     max per frame) of updating buffers since it is rare that we
     will need to update map vertices; it certainly does not have
     to be done every frame. This gives maximum performance, e.g.
     2000 fps. 2) We could maintain the buffer on the CPU side
     and just upload it each frame. The performance of this is
     not quite as good as (1), but it is still very good, e.g.
     800 fps. Going with the second option might be a good
     starting point, then if more performance is needed an/or it
     is feasible, we can completely move it onto the GPU.

# ===============================================================
# Global State
# ===============================================================

  1. Figure out a better way to handle remaining global variables
     used by the planes. This will probably involve putting the
     plane objects on the stack, which may be where they should
     go anyway. Maybe then we would not need plane configs since
     they could just somehow register themselves into a stack as
     they are created/destroyed.
  2. See if it is possible to create the game state on the stack
     somewhere instead of in a global variable and pass it down
     as function parameters (possibly only sub components).

# ===============================================================
# Game Saving
# ===============================================================

  1. Consider how to handle forward/backward compatibility in a
     generic way with model-based serialization. We could poten-
     tially have a way to define a schema (in Rcl) that would be
     used to check the model data as it is being serialized. We
     could save each version's schema and check all of them.
  2. Look into data compression for save files. I). Minify rcl as
     much as possible (maybe just add an option to not indent
     while emitting rcl). II). Compress with brotli or zstd.
     III). Export with base64.
  3. Replay?
  4. When saving the game, consider not saving any of the land
     data. Instead, just save the seed used to generate it, and
     allow the user the option to save in that format. That would
     produce 1) extremely small save files, and 2) extremely fast
     save times. That would be at the expense of 1) slower load
     times, since the land would have to be regenerated, and 2)
     version sensitivity in loading save files. At the very
     least, this method could be used for autosave files and for
     replay save files, since presumably those only need to be
     reopened by the same version of the game.

# ===============================================================
# Reflection
# ===============================================================

  1. Figure out a more general way to handle the validation that
     is done on the game state. Find a way (and place) to run
     validation methods recursively over a reflected struct so
     that the game state can be validated each turn. Run the com-
     plete validation at the start of each turn. Idea: create a
     new Foldable concept that can traverse a data structure and
     produce an accumulated value, possible with early termina-
     tion.
  2. Consider adding a generic mechanism for exposing reflected
     C++ types as Lua userdata (C++-owned).

# ===============================================================
# Config System
# ===============================================================

  1. Replace the config *.inl files with an Rds solution con-
     sisting of a reflected struct defining the config structure
     for each module. These Rds files can go in the config folder
     next to the rcl files.

# ===============================================================
# Type Safety
# ===============================================================

  1. Consider making `Commodity` move-only in order to enforce
     via the type system that commodities don't accidentally get
     created or destroyed except by sanctioned means. If a com-
     modity needs to be split, there can be a new method added
     onto it to break it up.

# ===============================================================
# Lua
# ===============================================================

  1. Add routine for converting from a Lua value to Cdr, and
     therefore to a C++ type. This operation will probably be ex-
     pensive. This may be a bit tricky because not all lua values
     can be converted to Cdr, e.g. lua functions. But
     to_canonical is not failable. Also, it doesn't seem right to
     make the luapp module depend on Cdr, so probably best to
     avoid making {to,from}_canonical overloads for lua types,
     and instead just make a separate API for converting them in
     the rn library. Another tricky thing will be dealing with
     empty lists, which in Lua are just empty tables, which are
     difficult to distinguish from empty tables...
  2. Add Lua module for generating a game state in Lua.
  3. Look into using the Teal language, a typed lua. It looks re-
     ally good, though some have said that it is not mature...
     https://github.com/teal-language/tl
  4. Add support for equality of userdata types in Lua. By de-
     fault a usertype should get an __equal metamethod that
     throws a Lua error when attempting to compare with anything,
     unless the cpp type is equality comparable, in which case it
     should get a proper comparison method.
  5. Create proper Lua API design in order to avoid coupling with
     the C++ modules.
  6. Add some other standard containers like vector,
     unordered_map, etc.

# ===============================================================
# Bugs
# ===============================================================

Low priority:

  - When we toggle from fullscreen to non-fullscreen the mouse
    position is a bit off. This is probably some kind of SDL
    issue where the window thinks that it is in a different posi-
    tion than where it is displayed on screen (off by about 10-20
    pixels). As soon as the window position is moved slightly (by
    dragging) then it is observed to self-correct. Somehow, after
    restoring the window, we need to tell the window to update
    itself.

# ===============================================================
# Build System
# ===============================================================

  - Add support for precompiled headers.  CMake recently added
    this feature and it should be available in a version post
    3.15.x (probably 3.16+).  See:

      https://gitlab.kitware.com/cmake/cmake/commit/fa36e2151d25358c7946a53c4440f0487210770d

  - Add Windows support.

# ===============================================================
# Infrastructure
# ===============================================================

  - Consider replacing any string-joining stuff with fmt::join,
    but first see if it will be included in C++20.

  - Add a generic texture cache to the cache module that can
    cache textures. It will also support pruning and/or automatic
    regeneration.

  - Add a cache to the cache module that invalidates when the
    scaling is changed. This may not be necessary since, as of
    now, it seems possible to write code that will work and ad-
    just to any scale.

# ===============================================================
# UI
# ===============================================================

  - Minimap

# ===============================================================
# Rendering
# ===============================================================

  - Fix handling of multiple units on a square with rendering.

  - Animate water.

# ===============================================================
# Basic Game Mechanics
# ===============================================================

  - Fix handling of multiple units on a square with combat.
  - Finish ship combat

  List of basic game mechanics:

    * All Units

        x sentry
        - goto
        x wait / forfeight
        x moving to friendly squares
        x click on unit to clear orders / open orders window.
        x disband

    * Land Units

        x fortifying
        x military unit attacking military unit
        x military unit attacking civilian
        - military unit attacking trade wagon / treasure
        - unit moving into lost city

    * Ships

        - ship attacking ship (evade, damage, sink)
        - privateer stealth

    * Land Units + Ships

        x ship holding units
        x land unit boarding ship
        x landfall
        - treasure boarding ship

# ===============================================================
# Old World View
# ===============================================================

  - Determine layout of europe background image
  - high seas
  - player gold
  - tax rate
  - unit immigration
  - purchasing units

# ===============================================================
# Terrain
# ===============================================================

  - movement affected by terrain
  - pioneer plow
  - pioneer road

# ===============================================================
# Colonies
# ===============================================================

  - Determine layout of europe background image

# ===============================================================
# Game Narrative
# ===============================================================

  - game year/season
  - royal army

# ===============================================================
# Graphics Engine
# ===============================================================

  - Remove color palette from config, it's kind of rediculous.
