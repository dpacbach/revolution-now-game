Rollout Process:

  Not Done:

  1.  Create refl/to-str.hpp to allow converting reflected types
      to strings.
  2.  Remove to_str from Rds files. May have to do this together
      with the previous step.
  3.  Find places, such as Coord, where we can add reflection
      manually (if it hasn't already been added by this point)
      and therefore remove the manual to_str overloads.
  4.  Ensure that all types that support rcl::convert_to also
      support Cdr, either via reflection or manually. Wherever
      there is an rcl::convert_to, put a static_assert inside its
      body to make sure that it supports FromCanonical, that
      should guarantee it for all relevant types. Where possible,
      add missing Cdr support to a type by manually adding re-
      flection (if it can't be moved to Rds) as opposed to manu-
      ally implementing FromCanonical.
  5.  Gut the bodies of all rcl::convert_to methods and forward
      it to from_canonical.
  6.  In config-files, bypass the rcl::convert_to and call the
      from_canonical directly on all types.
  7.  Remove the rcl::convert_to extension point.
  8.  Remove all traces of flatbuffers, but leaving per-module
      save-game data structures separate for the time being.
  9.  Find structs/classes that have to_str or manual reflection
      traits and move them into Rds, creating reflected wrappers
      as needed.
  10. Consolidate game state into one large data structure, in-
      cluding a semver number.
  11. Reimplement game saving by using to_canonical game state
      then converting to rcl. Do some profiling of game save/load
      times to see if it is ok.
  12. Add routine for converting from a Lua value to Cdr, and
      therefore to a C++ type. This operation will probably be
      expensive. This may be a bit tricky because not all lua
      values can be converted to Cdr, e.g. lua functions. But
      to_canonical is not failable. Also, it doesn't seem right
      to make the luapp module depend on Cdr, so probably best to
      avoid making {to,from}_canonical overloads for lua types,
      and instead just make a separate API for converting them in
      the rn library.
  13. Add Lua module for generating a game state in Lua.
  14. Replace the config *.inl files with an Rds solution con-
      sisting of a reflected struct defining the config structure
      for each module. These Rds files can go in the config
      folder next to the rcl files.
  15. Make sure that the Rds library and generated files do not
      have any dependencies on the rn library. Then move the
      (non-config) rds files into the src/ folder next to their
      associated source files, and add a cmake function to build
      Rds files in any library. We will need to put some in
      lower-level libraries, such as the rendering library.
  16. Consider replacing rcl data model with Cdr; figure out how
      to handle ordering of keys in table.
  17. Consider how to handle forward/backward compatibility in a
      generic way with model-based serialization. We could poten-
      tially have a way to define a schema (in Rcl) that would be
      used to check the model data as it is being serialized. We
      could save each version's schema and check all of them.

  Done:

  1.  Finish refl concepts design.
  2.  Create refl header in base library.
  3.  Figure out how to deal with wrappers.
  4.  Think of a name for the new data model and associated con-
      cepts.
  5.  Finalize new data model based architecture.
  6.  Define core data model.
  7.  Make sure that data model can interoperate with Lua.
  8.  Make sure that data model works with variants.
  9.  Make sure that data model works with base types, such as
      maybe and expect.
  10. Make sure that it supports maps in the way that we want.
  11. Make sure that it supports all of the datatypes that we
      will need for game saving, such as Matrix.
  12. Do maps need to support ordering of keys?
  13. Do maps need to support non-string keys?
  14. Add new concepts and extension point to data model library,
      with subconcepts of FromCanonical, ToCanonical.
  15. Add to_canonical and from_canonical implementations for
      some base types, std types, and builtin types.
  16. Add cdr.hpp to refl library to convert reflected types
      to/from Cdr.
  17. Add validation concept to refl library and call it from the
      ReflectedStruct implementation of from_canonical. It should
      be a const member function of the struct so that if the de-
      claration is removed then the definition won't linger.
  18. Any to_canonical that takes an unordered container to a
      cdr::list must sort the elements before hand.
  19. For map-like things that have keys that are convertible to
      strings, make the to_canonical implementation use Cdr ta-
      bles.
  20. Add Cdr module to Rcl to allow it to convert its data rep-
      resentation to Cdr.
  21. Add reflection output to Rds generated files.
  22. Check potential issue where Rcl table keys must be identi-
      fiers, e.g. cannot have spaces or weird characters. This
      may need to be checked when converting from Cdr.
  23. Add rcl module to emit the data model as rcl language. Note
      that we should not sort lists or table keys here since 1)
      the ordering inherited from the cdr model will have table
      keys ordered (since it uses std::map) and it will already
      have had its list elements sorted where applicable during
      the to_canonical conversion. Also, we must properly escape
      table keys as does the pretty printer in the model module.
