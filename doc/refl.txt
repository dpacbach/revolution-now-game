Rollout Process:

  Not Done:

  1.  Add reflection output to Rds generated files.
  2.  Ensure that all types that support rcl::convert_to also
      support Cdr, either via reflection or manually.
  3.  Gut the bodies of all rcl::convert_to methods and forward
      it to from_canonical.
  4.  In config-files, bypass the rcl::convert_to and call the
      from_canonical directly on all types.
  5.  Remove the rcl::convert_to extension point.
  6.  Add rcl module to emit the data model as rcl language. Note
      that we should not sort lists or table keys here since 1)
      the ordering inherited from the cdr model will have table
      keys ordered (since it uses std::map) and it will already
      have had its list elements sorted where applicable during
      the to_canonical conversion.
  7.  Add some reflection utilities for querying properties of
      structs or enums from the reflection traits.
  8.  Create refl/ext-to-str.hpp to allow converting reflected
      types to strings.
  9.  Remove to_str from Rds files. May have to do this together
      with the previous step.
  10. Find places, such as Coord, where we can add reflection
      manually (if it hasn't already been added by this point)
      and therefore remove the manual to_str overloads.
  11. Remove all traces of flatbuffers, but leaving per-module
      save-game data structures separate for the time being.
  12. Find structs/classes that have to_str or manual reflection
      traits and move them into Rds, creating reflected wrappers
      as needed.
  13. Consolidate game state into one large data structure, in-
      cluding a semver number.
  14. Reimplement game saving by using to_canonical game state
      then converting to rcl. Do some profiling of game save/load
      times to see if it is ok.
  15. Consider replacing rcl data model with Cdr; figure out how
      to handle ordering of keys in table.
  16. Consider how to handle forward/backward compatibility in a
      generic way with model-based serialization. We could poten-
      tially have a way to define a schema (in Rcl) that would be
      used to check the model data as it is being serialized. We
      could save each version's schema and check all of them.

  Done:

  1.  Finish refl concepts design.
  2.  Create refl header in base library.
  3.  Figure out how to deal with wrappers.
  4.  Think of a name for the new data model and associated con-
      cepts.
  5.  Finalize new data model based architecture.
  6.  Define core data model.
  7.  Make sure that data model can interoperate with Lua.
  8.  Make sure that data model works with variants.
  9.  Make sure that data model works with base types, such as
      maybe and expect.
  10. Make sure that it supports maps in the way that we want.
  11. Make sure that it supports all of the datatypes that we
      will need for game saving, such as Matrix.
  12. Do maps need to support ordering of keys?
  13. Do maps need to support non-string keys?
  14. Add new concepts and extension point to data model library,
      with subconcepts of FromCanonical, ToCanonical.
  15. Add to_canonical and from_canonical implementations for
      some base types, std types, and builtin types.
  16. Add cdr.hpp to refl library to convert reflected types
      to/from Cdr.
  17. Add validation concept to refl library and call it from the
      ReflectedStruct implementation of from_canonical. It should
      be a const member function of the struct so that if the de-
      claration is removed then the definition won't linger.
  18. Any to_canonical that takes an unordered container to a
      cdr::list must sort the elements before hand.
  19. For map-like things that have keys that are convertible to
      strings, make the to_canonical implementation use Cdr ta-
      bles.
  20. Add Cdr module to Rcl to allow it to convert its data rep-
      resentation to Cdr.
