Rollout Process:

  Not Done:

  1.  Find structs/classes that have manual reflection traits and
      move them into Rds, creating reflected wrappers as needed.
      There probably won't be any of these, but still good to
      check.
  2.  Find structs/classes that still have to_str overloads that
      don't need them and remove them (and/or move the type into
      Rds if necessary).
  3.  In config-files, bypass the rcl::convert_to and call the
      from_canonical directly on all types.
  4.  Remove the rcl::convert_to extension point.
  5.  Reimplement game saving by using to_canonical game state
      then converting to rcl. Do some profiling of game save/load
      times to see if it is ok.
  6.  Figure out a better way to handle remaining global state.
      This will probably involve putting the plane objects on the
      stack, which may be where they should go anyway. Maybe then
      we would not need plane configs since they could just
      somehow register themselves into a stack as they are creat-
      ed/destroyed.
  7.  Figure out a more general way to handle validation. Find a
      way (and place) to run validation methods recursively over
      a reflected struct so that the game state can be validated
      each turn. Run the complete validation at the start of each
      turn.
  8.  See if it is possible to create the game state on the stack
      somewhere instead of in a global variable and pass it down
      as function parameters (possibly only sub components).
  9.  Add routine for converting from a Lua value to Cdr, and
      therefore to a C++ type. This operation will probably be
      expensive. This may be a bit tricky because not all lua
      values can be converted to Cdr, e.g. lua functions. But
      to_canonical is not failable. Also, it doesn't seem right
      to make the luapp module depend on Cdr, so probably best to
      avoid making {to,from}_canonical overloads for lua types,
      and instead just make a separate API for converting them in
      the rn library.
  10. Add Lua module for generating a game state in Lua.
  11. Replace the config *.inl files with an Rds solution con-
      sisting of a reflected struct defining the config structure
      for each module. These Rds files can go in the config
      folder next to the rcl files.
  12. Make sure that the Rds library and generated files do not
      have any dependencies on the rn library. Then move the
      (non-config) rds files into the src/ folder next to their
      associated source files, and add a cmake function to build
      Rds files in any library. We will need to put some in
      lower-level libraries, such as the rendering library.
  13. Consider replacing rcl data model with Cdr; figure out how
      to handle ordering of keys in table.
  14. Consider how to handle forward/backward compatibility in a
      generic way with model-based serialization. We could poten-
      tially have a way to define a schema (in Rcl) that would be
      used to check the model data as it is being serialized. We
      could save each version's schema and check all of them.

  Done:

  1.  Finish refl concepts design.
  2.  Create refl header in base library.
  3.  Figure out how to deal with wrappers.
  4.  Think of a name for the new data model and associated con-
      cepts.
  5.  Finalize new data model based architecture.
  6.  Define core data model.
  7.  Make sure that data model can interoperate with Lua.
  8.  Make sure that data model works with variants.
  9.  Make sure that data model works with base types, such as
      maybe and expect.
  10. Make sure that it supports maps in the way that we want.
  11. Make sure that it supports all of the datatypes that we
      will need for game saving, such as Matrix.
  12. Do maps need to support ordering of keys?
  13. Do maps need to support non-string keys?
  14. Add new concepts and extension point to data model library,
      with subconcepts of FromCanonical, ToCanonical.
  15. Add to_canonical and from_canonical implementations for
      some base types, std types, and builtin types.
  16. Add cdr.hpp to refl library to convert reflected types
      to/from Cdr.
  17. Add validation concept to refl library and call it from the
      ReflectedStruct implementation of from_canonical. It should
      be a const member function of the struct so that if the de-
      claration is removed then the definition won't linger.
  18. Any to_canonical that takes an unordered container to a
      cdr::list must sort the elements before hand.
  19. For map-like things that have keys that are convertible to
      strings, make the to_canonical implementation use Cdr ta-
      bles.
  20. Add Cdr module to Rcl to allow it to convert its data rep-
      resentation to Cdr.
  21. Add reflection output to Rds generated files.
  22. Check potential issue where Rcl table keys must be identi-
      fiers, e.g. cannot have spaces or weird characters. This
      may need to be checked when converting from Cdr.
  23. Add rcl module to emit the data model as rcl language. Note
      that we should not sort lists or table keys here since 1)
      the ordering inherited from the cdr model will have table
      keys ordered (since it uses std::map) and it will already
      have had its list elements sorted where applicable during
      the to_canonical conversion. Also, we must properly escape
      table keys as does the pretty printer in the model module.
  24. Create refl/to-str.hpp to allow converting reflected types
      to strings.
  25. Remove to_str from Rds files. May have to do this together
      with the previous step.
  26. Ensure that all types that support rcl::convert_to also
      support Cdr, either via reflection or manually. Wherever
      there is an rcl::convert_to, put a static_assert inside its
      body to make sure that it supports FromCanonical, that
      should guarantee it for all relevant types. Where possible,
      add missing Cdr support to a type by manually adding re-
      flection (if it can't be moved to Rds) as opposed to manu-
      ally implementing FromCanonical.
  27. Find places, such as Coord, where we can add reflection
      manually (if it hasn't already been added by this point)
      and therefore remove the manual to_str overloads.
  28. Gut the bodies of all rcl::convert_to methods and forward
      it to from_canonical.
  29. Create a giant save-game struct in a new Rds file mirroring
      the structure of the current flatbuffers top-level struct.
  30. Ensure that all types that support flatbuffers also support
      Cdr, either via reflection, or manually.
  31. Remove all traces of flatbuffers, but leaving per-module
      save-game data structures separate for the time being.
  32. Move remaining serializable types into Rds files, creating
      wrappers where necessary.
  33. Add a unit test that makes sure that the new save-game
      structure supports Cdr.
  34. Find a place to instantiate the save-game structure (hope-
      fully in an RAII way) and move each module's global state
      over to it.
