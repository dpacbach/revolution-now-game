Button Views
============

// Handles rendering the button in pressed, non-pressed, or dis-
// abled state, keeps track of state, renders text. Does not
// handle input, and has no callbacks.
class ButtonViewBase;

// Represents a button that springs back up when clicked. Handles
// input, and has a callback that gets called on each click.
class ButtonSpringView;

Mouse Selection of Units
========================

Problem: currently, when units are given Fortify or Sentry orders
there is not simple way to clear those orders.

In the viewport either at an end-of-turn or when units are
blinking one will be able to click on a square with units and a
window will pop up listing the units in the square with their or-
ders shown in the nationality icon. The player will then be able
to clear orders by clicking on the unit. When finished the user
can press OK to accept the changes, or Cancel to cancel.

After a unit has its orders cleared it will be eligible to move
in that same turn if it didn't already move in that turn. So
e.g., if a unit is Fortified in one turn they can be reactivated
in the same turn, but they won't be able to move again until the
next turn.

Graphical Layout: the units will be arranged in a vertical line.

Note that even units in the square that already have their orders
cleared will still show up in the window to avoid confusing the
player.

Overall, the UX could be made much more polished (and robust, to
handle edge cases like large number of units), but here we are
concerned only with getting something functional.

Implementation.  There will be the following new views:

  - ButtonView: a button (see separate design doc).
  - UnitView: displays a unit and nat. icon.
  - UnitClearOrdersView: ties everything up into one large view
    which is then embedded in the window.

Text Rendering with Markup
==========================

RN will have a mechanism for rendering text with markup to modu-
late the style. The user interface for this will be that the user
will be able to pass in some text with special markup syntax
among the text and this will be interpreted and rendered with the
appropriate style.

The workflow of this implementation (and its interaction with a
word wrap) will be as follows:

  1) The user provides some text which may contain some markup
     tags.
  2) The text is flattened onto a single line if it is multiline
  3) The text is then wrapped (if requested) in such a way that
     markup characters are ignored (but still remain intact)
     in the wrapping.
  4) Each resulting line is parsed for markup characters and
     translated into a vector of markup descriptor objects, with
     each object containing a segment of text.
  5) When parsing a given line, the start of the line will be
     given the markup state from the end of the last line.
  6) At this point we have a vector of self-contained lines
     each of which is a vector of markup descriptor objects.
     Each of these lines will be sent to a rendering function
     that will render them with caching at the line level.
     This rendering will be done one character at a time.
  7) Then the lines will be rejoined into a paragraph.

Initially, this will just focus on a single markup feature: high-
light or no highlight.  The syntax will be as follows:

  "This is a @Htest@N.  In@Hs@Nide letters can be highlighted."
  "This is an email@@address.com with escaping."

Menu Item Click Handling
========================

  Menu Module
  -----------

  In order to avoid all menu handler code going into the menu
  module, it will be possible for modules to register handlers
  for menu items. This will consist of a void( e_menu_item )
  function to handle a click on the menu item and a
  bool(e_menu_item) function to return if the menu item should be
  enabled or disabled. The functions take arguments so that a
  registerer can use the same function for multiple items and use
  branching within the function to distinguish menu items.

    MENU_ITEM_HANDLER( game, save, is_enabled_func, handler_func );

  will roughly expand to:

    STARTUP() {
      register_menu_item_handler(
        e_menu_item::save_game,
        handler_func,
        is_enabled_func
      );
    }

  All menu items must have precisely one handler registered, and
  this is enforced during initialization.

  The menu module will call the is_enabled_func for each menu
  item each frame (so they should be light-weight). If a menu
  item is not enabled then it will be shown as disabled. If all
  menu items in a menu are disabled then that menu will not be
  shown.

  When a menu item is clicked (and it is enabled) then the
  handler_func will be called.

  Plane Module
  ------------

  Although some menu items might have handlers registered
  throughout the code base, most menu items will have handlers
  registered in the `plane` module.

  The plane module's implementation of the two callback methods
  will call a new virtual method on each of the Plane objects
  that asks the Plane for a handler function for a particular
  menu item. Specifically, the Plane will return:

    using MenuHandler = function<void()>;

    OptRef<MenuHandler> f( e_menu_item item ) {
      if( item == e_menu_item::restore_zoom ) {
        static MenuHandler handler = [this] {

        };
        return handler;
      }
      if( item == e_menu_item::sentry ) {
        static MenuHandler handler = [this] {

        };
        return handler;
      }
      return nullopt;
    }

  The plane module will cycle through the planes (from outer to
  inner) to find the first plane that can handle the menu item
  (i.e., returns non-nullopt).

  If at least one Plane returns a result that is not nullopt then
  that is taken as an indication that the menu item is enabled
  (otherwise it is disabled), and the function object contained
  therein (from the top-most (enabled) Plane that returned one)
  will be called to handle it if it is clicked.

  This new virtual method on Plane will have a default implemen-
  tation that just returns nullopt.

Menus
=====

  User Experience
  ---------------

  There will be a menu bar at the top of the screen. The user,
  when the game is open for input, will be able to open a menu
  and select an item. Alternatively they can use Alt-<Key> and
  the arrow keys to open menus.

  The menus that appear will generally depend on the state of the
  game. For example, when the user enters the europe view an ad-
  ditional menu might appear that allows the user to perform ac-
  tions relevant there. This might supplement some buttons that
  are already in that view.

  At some points in the game, such as when AI nations are making
  their moves, the menus will be off, in which case the menu bar
  will be empty (perhaps with the exception of save/quit/pause;
  this is yet to be decided). If all menus are off then the menu
  bar will disappear, possibly with a sliding animation.

  When the user clicks a top-level menu it will open and remain
  open even after releasing the mouse button. Hovering the mouse
  over the menu items will highlight each item, unless it happens
  to be disabled. Clicking on a menu item will animate a brief
  flash. While the menu is open, the top-level menu name will be
  highlighted, and dragging the mouse over other top-level menu
  items will open that particular menu without necessitating more
  clicks.

  Dragging: the user can also interact with the menus in the
  "dragging style". In this way, the user selects a top-level
  menu and keeps the mouse button held down, then moves to a menu
  item and releases the button. Upon release of the button the
  menu item will be selected.

    * Selecting menu items may cause windows to open, but the
      consequences of this might have to be dealt with separately.
    * Some items might be disabled depending on general game state
    * If all items in a top-level menu are disabled then that
      menu will be hidden.
    * If a menu is open and the user clicks outside of all menu
      UI items then then menu will close and the click will have
      a click-through behavior where it will be resent through the
      planes (still to be decided).
    * There can be dividers between groupings of menu items.

  Most menus will be on the left side of the screen, but some may
  be right justified, such as the Revolopedia menu.

  There will be a global function that can turn on/off all menus;
  when this happens the menus will disappear (maybe).

  Rendering
  ---------

    * There will be a shadow under open menus.
    * Hot-key letter of menu will be highlighted.

Combat
======

From a high level: when a unit with non-zero attack attempts to
enter a square with a unit form another nation then:

  a) If the two nations are at peace then a yes/no box pops up
     asking for confirmation.
  b) If not at peace then the attack just proceeds.

When the move is first is attempted the combat stats and outcome
will be computed during the analysis phase, even before any
confirmation boxes are presented to the player. If the player
proceeds then the previously-computed outcome is animated and
carried out. However, even though the outcome of the combat is
known before the confirmation is presented, the player will
obviously not be presented with the outcome until deciding to
proceed and seeing the animation.

If a unit attempts to attack with less than a full movement point
then they will take a penalty for that.

If there are multiple units in the target square then the one with
the best defense will be picked.

Each attack will consume only one movement point, so some units
may be able to attack multiple times per turn.  If a unit gets
demoted after an attack the resulting number of movement points
will be min( X, Y ) where X is the max movement points for the
demoted unit and Y is the number of movement points that the
non-demoted unit would have had had the attack been successful.

Mouse Dragging
==============

The mouse dragging framework will span a few different frameworks:

  1) The `input` module that translates the raw SDL event.

      The `input` module will supply two pieces of information
      with each event: whether a drag is in progress (and, if so,
      the point from which the dragging started) and a signal as
      to when it finishes. The former will generally span many
      events while the latter will correspond to just a single
      event.

      This module will communicate to the next stage the fol-
      lowing information: if the `engaged` field of the mouse
      state is set then that means that the drag is either in
      progress or just finished. If the `done` flag is set then
      the drag is just finished; the receiver of this event must
      be sure to react to this `done` event because the drag
      state will be reset on the very next event.

  2) The Plane module

      The `plane` module will intercept the dragging events and
      propagate them to the planes in a different way. When it
      detects a dragging event it will send it to the planes not
      through the usual input way but through some dedicated
      methods that distinguish dragging start/middle/end. Fur-
      thermore, when a new dragging event starts and a plane ac-
      cepts it then that same plane will continue to receive the
      dragging events for that dragging move until it ends. This
      way a user cannot start dragging on one plane and drag onto
      another.

  3) (where relevant) the window module

Auto-commands
=============

It will be useful for various purposes:

  * Unit movement that happens as a result of some different
    command, such as:
      * land-fall automatically unloading a unit
      * combat capturing a unit
      * other things
  * Cut scenes (animated sequences)
  * Testing

for units to be able to take orders automatically instead of
polling the user.  To this end, we do the following:

  For units there will be a global orders queue that will hold
  player orders.  When a unit needs orders this queue will be
  checked first, and then the order will be taken a processed
  as if the user had entered it manually, including any popup
  windows that might be needed.

  If a unit needs orders and there are none in the queue then
  (and only then) will the user be polled.

Applications:

  * When a ship is making landfall then the first unit onboard
    with available movement points will be given an auto command
    to move onto land.  It will also be push to the front of the
    orders queue, and the ship will "wait".  The unit will then
    immediately execute the order.  All units on the ship with
    movement points will be given the order.

Planes
======

There will be a fixed, ordered list of planes. There will be a
global enum with values for each plane, and this enum will reside
in the plane module.

The plane objects themselves will reside in the module that han-
dles rendering to it, and will in general refer to methods in
that module for input handling and rendering. The plane objects
will be gathered by the plane module and held in a central loca-
tion, keyed off of the enum.

For each plane there will be a texture the size of the screen. To
render the screen the planes are drawn in order. We do not reuse
the same texture just in case a plane decides that it does not
need to render on every frame (e.g., a plane that just displays
an image would only need to do so once).

A plane has the following methods/attributes:

  - enabled
  - draw.  This method will be given the texture.  (which the
    plane module manages and which will be automatically set
    as the rendering target).  The texture will be initialized
    with zero alpha everywhere. The draw method will be given, as
    a parameter, a value indicating the phase of animations,
    one for periodic and another monotonically increasing.
  - accept input, returning true/false depending on whether
    the input was handled or not.
  - covers_screen. In that case, and if the plane is enabled,
    planes under it are not rendered since they would not be
    visible (for efficiency).

The plane module will handle executing the drawing routines to
assemble the composite of the planes and their layers.

Input handling: user input in general will be passed through the
planes starting with the outer most one until a plane decides to
handle that input, at which point no further planes will be given
the opportunity to handle it. A plane must know how to accept
input and change its state accordingly.

Planes:
  0) Land/Units
  1) Panel
  2) Colony View
  3) Europe View
  4) Menus
  5) Images
  6) Windows
  7) Console

The compositor will produce a final texture that can then be
rendered to the main one.

Units on ships:
===============

  ✓ Each time a ship moves, all the units it contains will have
    their orders changed to `sentry`, in case the player activated
    a unit but never moved it onto land.
  ✓ If a unit is activated on a ship and the ship is waiting for
    orders and the player either hits `wait` or `pass` then this
    will not change the status of the unit in any way.
  * If a player clicks on a ship and actives units then their orders
    will be cleared and, if they have not already moved this turn,
    they will ask for orders at some point before the end of the
    turn.  If this happens at the end of turn then the units will
    ask for orders next turn.
  ✓ If a unit is activated on a ship and is waiting for orders and
    the user presses `wait` then the game will come back to the
    unit, assuming that the ship did not move in the mean time
    (which would have changed the unit back to `sentry`).
  ✓ If a unit is waiting for orders on a ship and the player hits
    `pass` then the unit's orders will not change.
  ✓ If a unit is waiting for orders on a ship then the only valid
    commands are: movement onto land, movement onto ship, wait,
    pass, sentry.
  * A unit waiting for orders on a ship cannot attack direcly from
    the ship (maybe a special unit could do this).
  ✓ A unit waiting for orders on a ship can move onto an adjacent
    ship of the same nationality, which consumes all their movement
    points.
  ✓ When a unit boards a ship it consumes all their movement pts.
  ✓ When a unit offboards a ship it consumes all their movement pts.
  ✓ When a ship carrying units attempts to move onto land:
     ✓ The ships movement points are NOT consumed.
     ✓ If there are no units with movement points then nothing happens.
     ✓ If there are units with movement points then:
        ✓ A window pops up asking if we want to make landfall.
        ✓ If yes, the following happens:
            ✓ All the units with movement points on the ship have
              their orders cleared.
            ✓ The units in the ship with movement
              points moves onto the land automatically.
            ✓ All the other units on the ship with movement points
              are put on the priority list to take orders next.
            ✓ The ship itself is given a `wait` order automatically.
            ✓ As a consequence of the above, the next unit on board
              with movements points starts to blink.

================================================================

Game loops:
==========

  start of turn:

    Iterate through the colonies, for each:

      * advance state of the colony

      * display messages to user any/or show animations where necessary

      * allow them to enter colony when events happens;
        in that case go to the colony screen game loop.When the user
        exits the colony screen then this colony iteration
        immediately proceeds;
        i.e., user cannot enter any other colonies.  This prevents the
        user from making last-minute changes to colonies that have not
        yet been advanced in this turn (otherwise that might allow
        cheating in some way).

      * during this time, the user is not free to scroll
        map (menus?) or make any changes to units.  They are also
        not allowed to enter colonies apart from the one that has
        just been processed.

    Advance the state of the old world, possibly displaying messages
    to the user where necessary.

    Iterate through all units, for each:

      * if it is it in `goto` mode focus on it and advance it
      * if it is a ship on the high seas then advance it
          if it has arrived in the old world then jump to the old world
          screen (maybe ask user whether they want to ignore),
          which has its own game loop (see old-world loop).
      * if it is in the old world then ignore it, or possibly remind
        the user it is there.
      * if it is performing an action, such as building a road,
        advance the state.  If it finishes then mark it as active
        so that it will wait for orders in the next step.
      * if it is in an indian village then advance it, and mark
        it active if it is finished.

      * if unit is waiting for orders then focus on it, and enter
        a realtime game loop where the user can interact with the
        map and GUI in general.  See `unit orders` game loop.

      * Make AI moves
          Make European moves
          Make Native moves
          Make expeditionary force moves

          Might want to do this in the Processing loop

      * if no player units needed orders then show a message somewhere
        that says "end of turn" and let the user interact with the
        map and GUI.

  Unit orders game loop:

    while state != unit accepted orders:

      render:
        render the the world without any units on it.  Color cycling
        animations here will use SDL_GetTicks to decide animation state.

        render all the colonies

        render all the units, with the focus animation using SDL_GetTicks
        to decide animation state.

      if state == unit awaiting orders && if input received:
        check if input valid
        if so then iniate movement animation, setting state to animation.
        ? need to figure this out more, but initially skip animations ?

      if state == animation:
        advance animation;
        if animation finished the mark state as
        `unit accepted orders`

      delay to maintain frame rate

  End of turn game loop:

  Colony screen game loop:

  Old World game loop:

  Message-window-over-world game loop:

    * This needs needs to be able to show a message and let the
      user interact with it while possibly still showing animations
      on the map in the background, but not letting the user interact
      with the map.

  Unit animation game loop: (needed?)

    * This includes sliding units and animations resulting from
      e.g. city upgrades.

  Processing game loop:

    * Any intensive processing task should probably be done in
      a separate thread with a loop running so that things remain
      responsive.
