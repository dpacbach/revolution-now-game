Menus
=====

  User Experience
  ---------------

  There will be a menu bar at the top of the screen. The user,
  when the game is open for input, will be able to open a menu
  and select an item. Alternatively they can use Alt-<Key> and
  the arrow keys to open menus.

  The menus that appear will generally depend on the state of the
  game. For example, when the user enters the europe view an ad-
  ditional menu might appear that allows the user to perform ac-
  tions relevant there. This might supplement some buttons that
  are already in that view.

  At some points in the game, such as when AI nations are making
  their moves, the menus will be off, in which case the menu bar
  will be empty (perhaps with the exception of save/quit/pause;
  this is yet to be decided).

  When the user clicks a top-level menu it will open and remain
  open even after releasing the mouse button. Hovering the mouse
  over the menu items will highlight each item, unless it happens
  to be disabled. Clicking on a menu item will animate a brief
  flash. While the menu is open, the top-level menu name will be
  highlighted, and dragging the mouse over other top-level menu
  items will open that particular menu without necessitating more
  clicks.

  Dragging: the user can also interact with the menus in the
  "dragging style". In this way, the user selects a top-level
  menu and keeps the mouse button held down, then moves to a menu
  item and releases the button. Upon release of the button the
  menu item will be selected.

    * Selecting menu items may cause windows to open, but the
      consequences of this might have to be dealt with separately.
    * Some items might be disabled depending on general game state
    * If all items in a top-level menu are disabled then that
      menu will be hidden.
    * If a menu is open and the user clicks outside of all menu
      UI items then then menu will close and the click will have
      a click-through behavior where it will be resent through the
      planes (still to be decided).
    * There can be dividers between groupings of menu items.

  Most menus will be on the left side of the screen, but some may
  be right justified, such as the Revolopedia menu.

  Implementation
  --------------

  Menus will occupy their own plane.

  Each frame, the menu rendering code will call a callback for
  each menu item to determine if it is enabled. If all items in a
  top-level menu are disabled then the menu will be hidden.
  Therefore, these callbacks should be very light-weight, because
  they will all be called on each frame.

  Every unique menu item (across all menus) will correspond to a
  unique enum value and MenuItem value:

  enum class e_menu {
    ...
  };

  struct Menu {
    std::string name;
    bool right_side;
    char hot_key;
  };

  absl::flat_hash_map<e_menu, Menu> g_menus{
    { ... }
  };

  // menu.hpp
  enum class e_menu_item {
    ...
  };

  struct MenuDivider {};

  // menu.cpp
  struct MenuClickable {
    e_menu_item item;
    std::string display_name;
    std::function<void(void)> on_click;
    std::function<bool(void)> enabled;
  };

  using Item = std::variant<MenuDivider, MenuClickable>;

  absl::flat_hash_map<e_menu, Vec<MenuItem>> g_menu_items{
    { ... }
  };

  absl::flat_hash_map<e_menu_item, Ref<MenuClickable>> g_menu_items{
    { ... }
  };

  When rendering the menu the items they will be separated into
  groups visually, separated by dividers whenever a MenuDivider
  is encountered. When displayed, the order of the top-level menu
  names will follow the order that they appear in the e_menu
  enum.

  Example:

    enum class e_menu {
      game = 0,
      edit = 1
    };

    absl::flat_hash_map<e_menu, Menu> g_menus{
      { e_menu::game,  { "Game",        false, 'G' }},
      { e_menu::edit,  { "Edit",        false, 'E' }},
      { e_menu::pedia, { "Revolopedia", true,  'R' }}
    };

    enum class e_menu_item {
      save_game,
      save_as_game,
      load_game,
      revolution,
      retire,
      exit,
      copy,
      paste
    };

    absl::flat_hash_map<e_menu, Vec<MenuItem>> g_menu_items{
      {e_menu::game,{
        MenuClickable{ e_menu_item::save_game,    "Save"       },
        MenuClickable{ e_menu_item::save_as_game, "Save As"    },
        MenuClickable{ e_menu_item::load_game,    "Load"       },
        MenuDivider,
        MenuClickable{ e_menu_item::revolution,   "Revolution" },
        MenuClickable{ e_menu_item::retire,       "Retire"     },
        MenuDivider,
        MenuClickable{ e_menu_item::exit,         "Exit"       }
      }},
      {e_menu::edit,{
        MenuClickable{ e_menu_item::copy,         "Copy"       },
        MenuClickable{ e_menu_item::paste,        "Paste"      }
      }}
    };

    +---------------------------------------------------------+
    | >Game<  Edit                                Revolopedia |
    +---------------------------------------------------------+
    | Save          |
    | Save As       |
    | Load          |
    | ------------- |
    | Revolution    |
    | ------------- |
    | Retire        |
    | Exit          |
    +---------------+

  In order to avoid all menu handler code going into the menu
  module, it will be possible for modules to register handlers
  for menu items. This will consist of a void(void) function to
  handle a click on the menu item and a bool(void) function to
  return if the menu item should be enabled or disabled.

    MENU_ITEM_HANDLER( game, save, is_enabled_func, handler_func );

  will roughly expand to:

    STARTUP() {
      register_menu_item_handler(
        e_menu_item::game__save,
        handler_func,
        is_enabled_func
      );
    }

  One can also register a handler for a menu that specifies a
  bool(void) callback that returns whether the menu is visible
  (or enabled; same thing here):

    MENU_HANDLERS( game, is_enabled_func );

  If a menu has no handler then it will assume default values,
  such as e.g. always visible (unless overridden by the corresop-
  nding global setting).

  The menu plane must hold state, which can be any of the follow-
  ing:

    menu_state = menus_off
               | menus_closed
               | menu_open

  If the state is menu_open then the animation state could be:

    menu_animation_state = none
                         | opening
                         | switching
                         | clicking
                         | closing

  Each of the above will be structs that may hold info specific
  to that state.

  There will be a global function that can turn on/off all menus;
  when this happens the menus will disappear.

  Initialization
  --------------

  There will be an initialization function call init_menus which
  must be done after SDL is initialized.  will do the following:

    * Will check that all e_menu_item values have a handler
      registered.
    * Will render each menu items in (enabled|disabled|selected)
      states.
    * Will render each menu name in (enabled|selected) states.

  Rendering
  ---------

  There will be a shadow under open menus.

  Hot-key letter of menu will be highlighted.

  Determining Menu State
  ----------------------

  The callback functions for each menu item will determine the
  menu state. That mechanism will work as follows:

Combat
======

From a high level: when a unit with non-zero attack attempts to
enter a square with a unit form another nation then:

  a) If the two nations are at peace then a yes/no box pops up
     asking for confirmation.
  b) If not at peace then the attack just proceeds.

When the move is first is attempted the combat stats and outcome
will be computed during the analysis phase, even before any
confirmation boxes are presented to the player. If the player
proceeds then the previously-computed outcome is animated and
carried out. However, even though the outcome of the combat is
known before the confirmation is presented, the player will
obviously not be presented with the outcome until deciding to
proceed and seeing the animation.

If a unit attempts to attack with less than a full movement point
then they will take a penalty for that.

If there are multiple units in the target square then the one with
the best defense will be picked.

Each attack will consume only one movement point, so some units
may be able to attack multiple times per turn.  If a unit gets
demoted after an attack the resulting number of movement points
will be min( X, Y ) where X is the max movement points for the
demoted unit and Y is the number of movement points that the
non-demoted unit would have had had the attack been successful.

Mouse Dragging
==============

The mouse dragging framework will span a few different frameworks:

  1) The `input` module that translates the raw SDL event.

      The `input` module will supply two pieces of information
      with each event: whether a drag is in progress (and, if so,
      the point from which the dragging started) and a signal as
      to when it finishes. The former will generally span many
      events while the latter will correspond to just a single
      event.

      This module will communicate to the next stage the fol-
      lowing information: if the `engaged` field of the mouse
      state is set then that means that the drag is either in
      progress or just finished. If the `done` flag is set then
      the drag is just finished; the receiver of this event must
      be sure to react to this `done` event because the drag
      state will be reset on the very next event.

  2) The Plane module

      The `plane` module will intercept the dragging events and
      propagate them to the planes in a different way. When it
      detects a dragging event it will send it to the planes not
      through the usual input way but through some dedicated
      methods that distinguish dragging start/middle/end. Fur-
      thermore, when a new dragging event starts and a plane ac-
      cepts it then that same plane will continue to receive the
      dragging events for that dragging move until it ends. This
      way a user cannot start dragging on one plane and drag onto
      another.

  3) (where relevant) the window module

Auto-commands
=============

It will be useful for various purposes:

  * Unit movement that happens as a result of some different
    command, such as:
      * land-fall automatically unloading a unit
      * combat capturing a unit
      * other things
  * Cut scenes (animated sequences)
  * Testing

for units to be able to take orders automatically instead of
polling the user.  To this end, we do the following:

  For units there will be a global orders queue that will hold
  player orders.  When a unit needs orders this queue will be
  checked first, and then the order will be taken a processed
  as if the user had entered it manually, including any popup
  windows that might be needed.

  If a unit needs orders and there are none in the queue then
  (and only then) will the user be polled.

Applications:

  * When a ship is making landfall then the first unit onboard
    with available movement points will be given an auto command
    to move onto land.  It will also be push to the front of the
    orders queue, and the ship will "wait".  The unit will then
    immediately execute the order.  All units on the ship with
    movement points will be given the order.

Planes
======

There will be a fixed, ordered list of planes. There will be a
global enum with values for each plane, and this enum will reside
in the plane module.

The plane objects themselves will reside in the module that han-
dles rendering to it, and will in general refer to methods in
that module for input handling and rendering. The plane objects
will be gathered by the plane module and held in a central loca-
tion, keyed off of the enum.

For each plane there will be a texture the size of the screen. To
render the screen the planes are drawn in order. We do not reuse
the same texture just in case a plane decides that it does not
need to render on every frame (e.g., a plane that just displays
an image would only need to do so once).

A plane has the following methods/attributes:

  - enabled
  - draw.  This method will be given the texture.  (which the
    plane module manages and which will be automatically set
    as the rendering target).  The texture will be initialized
    with zero alpha everywhere. The draw method will be given, as
    a parameter, a value indicating the phase of animations,
    one for periodic and another monotonically increasing.
  - accept input, returning true/false depending on whether
    the input was handled or not.
  - covers_screen. In that case, and if the plane is enabled,
    planes under it are not rendered since they would not be
    visible (for efficiency).

The plane module will handle executing the drawing routines to
assemble the composite of the planes and their layers.

Input handling: user input in general will be passed through the
planes starting with the outer most one until a plane decides to
handle that input, at which point no further planes will be given
the opportunity to handle it. A plane must know how to accept
input and change its state accordingly.

Planes:
  0) Land/Units
  1) Panel
  2) Colony View
  3) Europe View
  4) Menus
  5) Images
  6) Windows
  7) Console

The compositor will produce a final texture that can then be
rendered to the main one.

Units on ships:
===============

  ✓ Each time a ship moves, all the units it contains will have
    their orders changed to `sentry`, in case the player activated
    a unit but never moved it onto land.
  ✓ If a unit is activated on a ship and the ship is waiting for
    orders and the player either hits `wait` or `pass` then this
    will not change the status of the unit in any way.
  * If a player clicks on a ship and actives units then their orders
    will be cleared and, if they have not already moved this turn,
    they will ask for orders at some point before the end of the
    turn.  If this happens at the end of turn then the units will
    ask for orders next turn.
  ✓ If a unit is activated on a ship and is waiting for orders and
    the user presses `wait` then the game will come back to the
    unit, assuming that the ship did not move in the mean time
    (which would have changed the unit back to `sentry`).
  ✓ If a unit is waiting for orders on a ship and the player hits
    `pass` then the unit's orders will not change.
  ✓ If a unit is waiting for orders on a ship then the only valid
    commands are: movement onto land, movement onto ship, wait,
    pass, sentry.
  * A unit waiting for orders on a ship cannot attack direcly from
    the ship (maybe a special unit could do this).
  ✓ A unit waiting for orders on a ship can move onto an adjacent
    ship of the same nationality, which consumes all their movement
    points.
  ✓ When a unit boards a ship it consumes all their movement pts.
  ✓ When a unit offboards a ship it consumes all their movement pts.
  ✓ When a ship carrying units attempts to move onto land:
     ✓ The ships movement points are NOT consumed.
     ✓ If there are no units with movement points then nothing happens.
     ✓ If there are units with movement points then:
        ✓ A window pops up asking if we want to make landfall.
        ✓ If yes, the following happens:
            ✓ All the units with movement points on the ship have
              their orders cleared.
            ✓ The units in the ship with movement
              points moves onto the land automatically.
            ✓ All the other units on the ship with movement points
              are put on the priority list to take orders next.
            ✓ The ship itself is given a `wait` order automatically.
            ✓ As a consequence of the above, the next unit on board
              with movements points starts to blink.

================================================================

Game loops:
==========

  start of turn:

    Iterate through the colonies, for each:

      * advance state of the colony

      * display messages to user any/or show animations where necessary

      * allow them to enter colony when events happens;
        in that case go to the colony screen game loop.When the user
        exits the colony screen then this colony iteration
        immediately proceeds;
        i.e., user cannot enter any other colonies.  This prevents the
        user from making last-minute changes to colonies that have not
        yet been advanced in this turn (otherwise that might allow
        cheating in some way).

      * during this time, the user is not free to scroll
        map (menus?) or make any changes to units.  They are also
        not allowed to enter colonies apart from the one that has
        just been processed.

    Advance the state of the old world, possibly displaying messages
    to the user where necessary.

    Iterate through all units, for each:

      * if it is it in `goto` mode focus on it and advance it
      * if it is a ship on the high seas then advance it
          if it has arrived in the old world then jump to the old world
          screen (maybe ask user whether they want to ignore),
          which has its own game loop (see old-world loop).
      * if it is in the old world then ignore it, or possibly remind
        the user it is there.
      * if it is performing an action, such as building a road,
        advance the state.  If it finishes then mark it as active
        so that it will wait for orders in the next step.
      * if it is in an indian village then advance it, and mark
        it active if it is finished.

      * if unit is waiting for orders then focus on it, and enter
        a realtime game loop where the user can interact with the
        map and GUI in general.  See `unit orders` game loop.

      * Make AI moves
          Make European moves
          Make Native moves
          Make expeditionary force moves

          Might want to do this in the Processing loop

      * if no player units needed orders then show a message somewhere
        that says "end of turn" and let the user interact with the
        map and GUI.

  Unit orders game loop:

    while state != unit accepted orders:

      render:
        render the the world without any units on it.  Color cycling
        animations here will use SDL_GetTicks to decide animation state.

        render all the colonies

        render all the units, with the focus animation using SDL_GetTicks
        to decide animation state.

      if state == unit awaiting orders && if input received:
        check if input valid
        if so then iniate movement animation, setting state to animation.
        ? need to figure this out more, but initially skip animations ?

      if state == animation:
        advance animation;
        if animation finished the mark state as
        `unit accepted orders`

      delay to maintain frame rate

  End of turn game loop:

  Colony screen game loop:

  Old World game loop:

  Message-window-over-world game loop:

    * This needs needs to be able to show a message and let the
      user interact with it while possibly still showing animations
      on the map in the background, but not letting the user interact
      with the map.

  Unit animation game loop: (needed?)

    * This includes sliding units and animations resulting from
      e.g. city upgrades.

  Processing game loop:

    * Any intensive processing task should probably be done in
      a separate thread with a loop running so that things remain
      responsive.
