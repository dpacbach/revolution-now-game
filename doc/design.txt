Planes
======

There will be a fixed, ordered list of planes. There will be a
global enum with values for each plane, and this enum will reside
in the plane module.

The plane objects themselves will reside in the module that han-
dles rendering to it, and will in general refer to methods in
that module for input handling and rendering. The plane objects
will be gathered by the plane module and held in a central loca-
tion, keyed off of the enum.

For each plane there will be a texture the size of the screen. To
render the screen the planes are drawn in order. We do not reuse
the same texture just in case a plane decides that it does not
need to render on every frame (e.g., a plane that just displays
an image would only need to do so once).

A plane has the following methods/attributes:

  - enabled
  - draw.  This method will be given the texture.  (which the
    plane module manages and which will be automatically set
    as the rendering target).  The texture will be initialized
    with zero alpha everywhere. The draw method will be given, as
    a parameter, a value indicating the phase of animations,
    one for periodic and another monotonically increasing.
  - accept input, returning true/false depending on whether
    the input was handled or not.
  - covers_screen. In that case, and if the plane is enabled,
    planes under it are not rendered since they would not be
    visible (for efficiency).

The plane module will handle executing the drawing routines to
assemble the composite of the planes and their layers.

Input handling: user input in general will be passed through the
planes starting with the outer most one until a plane decides to
handle that input, at which point no further planes will be given
the opportunity to handle it. A plane must know how to accept
input and change its state accordingly.

Planes:
  0) Land/Units
  1) Panel
  2) Colony View
  3) Europe View
  4) Menus
  5) Images
  6) Windows
  7) Console

The compositor will produce a final texture that can then be
rendered to the main one.

Units on ships:
===============

  ✓ Each time a ship moves, all the units it contains will have
    their orders changed to `sentry`, in case the player activated
    a unit but never moved it onto land.
  ✓ If a unit is activated on a ship and the ship is waiting for
    orders and the player either hits `wait` or `pass` then this
    will not change the status of the unit in any way.
  * If a player clicks on a ship and actives units then their orders
    will be cleared and, if they have not already moved this turn,
    they will ask for orders at some point before the end of the
    turn.  If this happens at the end of turn then the units will
    ask for orders next turn.
  ✓ If a unit is activated on a ship and is waiting for orders and
    the user presses `wait` then the game will come back to the
    unit, assuming that the ship did not move in the mean time
    (which would have changed the unit back to `sentry`).
  ✓ If a unit is waiting for orders on a ship and the player hits
    `pass` then the unit's orders will not change.
  ✓ If a unit is waiting for orders on a ship then the only valid
    commands are: movement onto land, movement onto ship, wait,
    pass, sentry.
  * A unit waiting for orders on a ship cannot attack direcly from
    the ship (maybe a special unit could do this).
  ✓ A unit waiting for orders on a ship can move onto an adjacent
    ship of the same nationality, which consumes all their movement
    points.
  ✓ When a unit boards a ship it consumes all their movement pts.
  ✓ When a unit offboards a ship it consumes all their movement pts.
  * When a ship carrying units attempts to move onto land:
     ✓ The ships movement points are NOT consumed.
     ✓ If there are no units with movement points then nothing happens.
     * If there are units with movement points then:
        ✓ A window pops up asking if we want to make landfall.
        * If yes, the following happens:
            ✓ All the units with movement points on the ship have
              their orders cleared.
            * The first unit in the ship with movement
              points moves onto the land automatically.
            ✓ All the other units on the ship with movement points
              are put on the priority list to take orders next.
            ✓ The ship itself is given a `wait` order automatically.
            ✓ As a consequence of the above, the next unit on board
              with movements points starts to blink.

================================================================

Game loops:

  start of turn:

    Iterate through the colonies, for each:

      * advance state of the colony

      * display messages to user any/or show animations where necessary

      * allow them to enter colony when events happens;
in that case go to the colony screen game loop.When the user
    exits the colony screen then this colony iteration
        immediately proceeds;
        i.e., user cannot enter any other colonies.  This prevents the
        user from making last-minute changes to colonies that have not
        yet been advanced in this turn (otherwise that might allow
        cheating in some way).

      * during this time, the user is not free to scroll
        map (menus?) or make any changes to units.  They are also
        not allowed to enter colonies apart from the one that has
        just been processed.

    Advance the state of the old world, possibly displaying messages
    to the user where necessary.

    Iterate through all units, for each:

      * if it is it in `goto` mode focus on it and advance it
      * if it is a ship on the high seas then advance it
          if it has arrived in the old world then jump to the old world
          screen (maybe ask user whether they want to ignore),
          which has its own game loop (see old-world loop).
      * if it is in the old world then ignore it, or possibly remind
        the user it is there.
      * if it is performing an action, such as building a road,
        advance the state.  If it finishes then mark it as active
        so that it will wait for orders in the next step.
      * if it is in an indian village then advance it, and mark
        it active if it is finished.

      * if unit is waiting for orders then focus on it, and enter
        a realtime game loop where the user can interact with the
        map and GUI in general.  See `unit orders` game loop.

      * Make AI moves
          Make European moves
          Make Native moves
          Make expeditionary force moves

          Might want to do this in the Processing loop

      * if no player units needed orders then show a message somewhere
        that says "end of turn" and let the user interact with the
        map and GUI.

  Unit orders game loop:

    while state != unit accepted orders:

      render:
        render the the world without any units on it.  Color cycling
        animations here will use SDL_GetTicks to decide animation state.

        render all the colonies

        render all the units, with the focus animation using SDL_GetTicks
        to decide animation state.

      if state == unit awaiting orders && if input received:
        check if input valid
        if so then iniate movement animation, setting state to animation.
        ? need to figure this out more, but initially skip animations ?

      if state == animation:
        advance animation;
        if animation finished the mark state as
        `unit accepted orders`

      delay to maintain frame rate

  End of turn game loop:

  Colony screen game loop:

  Old World game loop:

  Message-window-over-world game loop:

    * This needs needs to be able to show a message and let the
      user interact with it while possibly still showing animations
      on the map in the background, but not letting the user interact
      with the map.

  Unit animation game loop: (needed?)

    * This includes sliding units and animations resulting from
      e.g. city upgrades.

  Processing game loop:

    * Any intensive processing task should probably be done in
      a separate thread with a loop running so that things remain
      responsive.
