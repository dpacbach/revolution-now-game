Finite State Machine
====================

Introduction

  There will be a finite state machine class called `fsm`. It
  will be a class template using CRTP as well as other types
  needed, which will include:

  - Variant representing state.
  - Variant representing events.
  - Type map from <StateT, EventT> -> <StateT>.
  - Mapping from (State1, Event, State2) -> Action.
  - Initial state type.

The API of `fsm` will be:

  - Reset: resets the state to the initial state.

  - Queue event: signal to the state machine that an event has
    happened. fsm will queue it for later.

  - Perform next event: take the next event from the queue, if
    any, and do double dispatch to map the state and event types
    to a new state type, then it will call a child method with
    the following signature:

      State2_t transition( State1_t const&, Event1_t const& );

    if one exists (will try to determine this with SFINAE). If it
    doesn't exist then it will just default construct the final
    state. Then it will look for a function with this signature:

      void action( State1_t const&, Event1_t const&, State2_t const& );

    and if one exists it will call it to perform an action.

    If there exists no such transition (even a transition that
    keeps the state the same) then the fsm will fail with an
    error (probably has to be a runtime error even though we have
    a compile time type map).

  - Get state. Returns a const reference to the internal variant
    state.

  - Query if holds state of type.

Auto Transitions

  An auto-transition can be implemented in a way such that when-
  ever a state is entered the action function will enqueue a new
  event which will bring it out of that state. This should be
  possible by e.g. defining the action function so that the
  "from" state is the state variant type so that it should act as
  a catch-all.

List of Current FSMs

  The following is a list of current candidates for FSMs that
  must be supported by the above model:

    - Music Players / Conductor:
    - Drag & Drop:
    - Plane+Modal Windows:
    - Plane (or input module) Drag & Drop:
    - Menus:
    - Overall Program State:
    - Game State (i.e., pre/post revolution):
    - Unit orders:
    - Ship damage status:
    - Viewport (maybe):
    - Game world animation state (e.g. unit sliding):
    - Intra-turn state:

Plane Integration of FSM

  If each plane has its own top-level FSM then it might make
  sense to allow the generic plane manager code to do as much of
  the work as possible.

  It is not clear yet whether this will be needed.

Pushdown Automata

  This will be a type that exposes an fsm API and also takes an
  FSM type as a template paramter. It will maintain a stack of
  state machines. The PDA will act as a state machine where the
  state is held by the FSM at the top of the stack. New FSMs can
  be pushed/popped using special API methods.

  It is not clear yet whether this will be needed.

Drag & Drop with Dialog Box
===========================

In general it will be necessary to allow the drag & drop frame-
work to pop up a dialog box and ask the user for more information
when a successfull drag is completed. In other words, when the
user releases the mouse to complete (what is or may be) a suc-
cessful drag a dialog box will pop up asking the user for input
before affecting the drag&drop action.

Some possible use cases for this could be:

  - Asking the user how much of a quantity they wish to drop
    (which it might do when the user holds down shift while drag-
    ging).
  - Asking the user to confirm the drag.

The following implementation assumes a future where both the drag
and drop framework as well as the relevant plane are operated
with finite state machines.

  - When the plane is notified that a drag is finished then we
    call the drag & drop class to handle it as usual.
  - If the resulting drag is verified to be valid then it will
    compute the drag arc as usual.
  - If valid, the drag & drop framework will set its state to
    "waiting for finalization."
  - The drag arc will then be given to the child class along with
    any necessary additional metadata to give the child a chance
    to alter it. This method will be called "finalize drag arc.":

      void finalize_drag_arc( DragArcT const& drag_arc ) const;

  - When the child has the result (which it may have immediately
    if no processing is necessary) then it will call an API
    method called "accept finalized drag arc." The framework will
    throw an error if this method is called when not in the ap-
    propriate state.

      void accept_finalized_drag_arc(
               Opt<CRef<DragArcT>> maybe_drag_arc ) final;

    If nullopt is provided then the drag will be cancelled.
  - The framework will test the resulting drag arc once more for
    validity. If invalid then it will throw an error (maybe).
  - If the drag is valid then it will transition to a "complete"
    state and will store the drag arc (not perform it).
  - As usual, when in the complete state, it will not accept any
    further drags until the stored one has been performed.
  - On the next frame, the plane will see the stored arc and will
    perform it by calling an API method called "perform drag if
    ready."
  - After performing the drag the framework will reset its state.

The following is an example of the workflow of the plane and
child drag&drop class during the "waiting for finalization" state
where a dialog box needs to be presented to the user to ask for
the quantity of commodity to be dragged:

  - As stated above, the framework will put itself into a
    "waiting for finalization state" and then call a child method
    with the drag arc.
  - The child class will add an event into the plane's event
    queue to signal to it to ask the user for quantity. This
    event can only be accepted when the plane is in the dragging
    state (though at first, try without dragging state as it may
    not be necessary).
  - The plane will then pop up the quantity box and wait for the
    user to enter. The result could either be OK (with a quantity
    or cancel) which would cancel the drag.
  - The window will be instructed that, when it closes, it should
    put its result (an Opt<int>) into an event and then add that
    event into the plane's event queue to signal that it has
    closed.
  - The plane will then transition back to the "waiting for drag"
    state (or the normal state) that it was in during the drag,
    and in so doing, it will call the drag&drop child's "accept
    quantity" function.
  - The "accept quantity" will then adjust the (stored) drag arc
    and then call the parent's "accept finalized drag arc" func-
    tion.

Drag & Drop Framework
=====================

The goal is to create a generic drag-n-drop framework that can be
used anywhere where dragging and dropping of items is needed.

Currently the input/plane mechanism supports sending dragging
messages so that a plane can easily handle dragging, but it does
not handle dragging of items per se.

Here we will create a framework that allows configuring a drag &
drop configuration object which can be configured with a descrip-
tion of all the ways in which things can be dragged and dropped
in a particular scene, such as the set of things that can be
dragged, the set of things that can receive a drop, which items
can be dropped where, what should happen to the dragged item
during dragging, etc.

See code for API/implementation results.

Old World Dock Screen
=====================

  - Create a dynamic square that is always centered but that can
    be dragged with a mouse to different sizes and aspect ratios.
    This will allow simulating screen dimensions while designing
    the UI without having to change the size of the window.
  - Create a series of old world UI objects; each of these ob-
    jects knows how to do the following:

      - Take a rectangle and then compute its configuration and
        position. From this can be computed a bounding rectangle.
      - Draw itself given configuration and position.
      - Determine if it is not possible to draw itself.

  - Each frame, all the UI elements will be asked to compute
    their positions and configurations. The scene will be X'd out
    if:

      - Any element cannot draw itself.
      - Any two elements overlap.
      - Any element runs out of bounds of the rectangle.

    Otherwise, the scene can be drawn.
  - Element positions/configurations will be cached with key
    being the rectangle size, although this may not be necessary.

Elements:

  - Outbound ships
  - Inbound ships
  - Ships in dock
  - Dock
  - Units on dock
  - Ship cargo
  - Market commodities
  - Exit button
  - Buttons
  - Message box
  - Stats area (money, tax rate, etc.)

Music Conductor (conductor.h/conductor.cpp)
===============

The `conductor` module is the interface that the rest of the game
uses to the music system. It performs the following roles:

  - Gathers all of the different music players.
  - Selecting/switching music player.
  - Taking commands from the user/game to control the music
    player, such as current tune, volume, play, stop, etc.
  - Managing the playlist. This includes figuring out which song
    to play when.

The interface will be a collection of functions in a namespace:

  namespace conductor {

  enum class e_music_player {
    silent,
    midiseq
  };

  enum class e_conductor_event {
    start_tune,
    finish_tune,
    volume_change,
    pause,
    resume,
    mplayer_changed
  };

  enum class e_music_state {
    playing,
    stopped,
    paused
  };

  enum class e_special_music_event {
    fountain_of_youth,
    king_raise_taxes,
    founding_father
  };

  struct ConductorInfo {
    e_music_player         mplayer;
    e_music_state          music_state;
    Opt<TunePlayerInfo>    playing_now;
    Opt<double>            volume;
    bool                   autoplay;
  };

  struct MusicPlayerInfo {
    bool        enabled;
    std::string name;
    std::string description;
    std::string how_it_works;
  };

  MusicPlayerInfo const& music_player_info( e_music_player mplayer );

  // Stops any playing music and changes the music player. Re-
  // turns true if success and false otherwise. If it fails then
  // no music player will be enabled.
  bool set_music_player( e_music_player mplayer );

  // Get the current state of the conductor. If no music players
  // are available then we get an `unexpected`.
  expect<ConductorInfo> state();

  // This will allow other code to recieve messages when the con-
  // ductor performs certain events. It will always send the no-
  // tification after the event. All functions are called in the
  // game's main thread.
  void subscribe_to_event(
        e_conductor_event, std::function<void(void)> );

  // If this is off then the conductor will never automatically
  // advance to the next tune when one is complete.
  void set_autoplay( bool enabled );

  // Play. If a tune is specified the it will start with that one
  // and then keep playing (from the random playlist if autoplay
  // is enabled). Otherwise, if a tune is not specified, it will
  // enable auto play and start playing.
  void play( Opt<TuneId> id );

  // Skip to beginning of this tune if > 5% progress, or previous
  // tune if < 5% progress. If progress is not available then
  // just skip to previous tune.
  void prev();

  // Skip to next tune in playlist. If we are paused this will go
  // into the stop state after advancing to the next tune. If we
  // are stopped then it will just advance to the next tune. In
  // any case it will not start player.
  void next();

  // Stop playing current tune (if playing) and forget current
  // place in tune.
  void stop();

  // If supported, stop playing but remember place in tune.
  void pause();

  // If supported, and if paused, resume playing.
  void resume();

  // If supported, jump to a certain place [0,1.0] in tune.
  void seek( double pos );

  // Tune Selection. Each of these methods will search through
  // available tunes and select one that meets the criteria and
  // then play it if requested. If the tune is played then the
  // conductor will return to autoplay when it is finished, if
  // autoplay is enabled.
  #define PLAY( what ) \
    TuneId what( bool play = true )

  namespace play {
    PLAY( won_battle_europeans );
    PLAY( won_battle_natives );
    PLAY( lost_battle_europeans );
    PLAY( lost_battle_natives );

    PLAY( slow_sad );
    PLAY( medium_tempo );
    PLAY( happy_fast );

    PLAY( orchestrated );
    PLAY( fiddle_tune );
    PLAY( fife_drum_sad );
    PLAY( fife_drum_slow );
    PLAY( fife_drum_fast );
    PLAY( fife_drum_happy );

    PLAY( native_sad );
    PLAY( native_happy );

    PLAY( king_happy );
    PLAY( king_sad );
    PLAY( king_war );
  }

  // Playlists.

  // Get full playlist and current tune (or next up if not play-
  // ing).
  std::pair<Vec<TuneId>,int> const& playlist();

  // Generate a random playlist. If one exists it will be regen-
  // erated (we will not merely shuffle here because the playlist
  // must satisfy some invariants).
  playlist_generate();

  // E.g. if we want a playlist that excludes all native tunes or
  // all post-revolution tunes. If playing this will take effect
  // on the next tune.
  playlist_generate_excluding( TuneOptDimensions dimensions );

  }

Initialization

When the conductor initializes it does a few things:

  - Generates a random playlist using playlist_generate().

  - Gathers a list of all available music players. Each music
    player will correspond to an enum value in e_music_player. A
    map will be created from enum to music player info and an-
    other map to MusicPlayer pointer (by calling the Music Play-
    er's static `player` method).

  - The conductor will set the active music player by consulting
    the config file for the first choice; if that is not avail-
    able there will be a second choice. If none of those are
    available then the first available one will be selected. If
    none are available then the conductor simply will not play
    music, though its API methods can still be called in general.
    It may be desirable during development to have the default
    music player be the "silent" one so that the game can still
    be tested with a music player enabled but no music will be
    produced until the music player is switched.

  - In order for a music player to be considered as enabled it
    must meet a few criteria. 1. good() == true. 2. The
    can_play_tune must return true for all tunes. The init rou-
    tine will check this.

  - The conductor will make sure that there is precisely one tune
    associated to each special music event, and this would come
    from the conductor's config file.

Playlist Generation

  For this it will first generate a random list of tunes,
  choosing among all the tunes who have purpose=standard. The
  length of this list will be 10 times the total number of tunes.
  This list must obey two constraints: 1. it cannot play a tune
  that was already played in the last five items in the playlist,
  unless there are fewer than five total tunes. 2. the last tune
  shall not be the same as the first tune. Finally, it will take
  the list and create an infinite cycle out of it effectively
  creating an infinite random-sounding playlist.

Tick

  Since the conductor does not run in its own thread it needs to
  be sent ticks on each frame so that it can manage things like
  autoplay. This will be done via a new frame-loop-subscription
  API in the frame module. The conductor module will supply a
  callback that does the following:

    - Maintains a counter and just increments the counter on each
      call. When the counter hits a threshold value (specified in
      config files) then the tick callback will perform its du-
      ties, otherwise it will just return and do nothing to avoid
      adding any overhead to the frame loop.

    - Will check up on the current music player to make sure that
      it is still in good condition. If not then it will attempt
      to switch to another music player.

    - If no tunes are playing and autoplay is enabled then it
      will kick off the next tune in the playlist.

  Note: this should be called each frame (will be lightweight)
  but the timing does not matter precisely, because e.g. this is
  not being used to generate music (that will always happen asyn-
  chronously for all music players).

Music Player (mplayer.h/mplayer.cpp)
============

Music will be played via Music Players. A music player is an ob-
ject that implements a music player interface with virtual meth-
ods. A concrete music player will derive from the base class.

Some possible concrete music players are:

  - OGG/WAV player
  - MP3 player
  - MidiSequencerMusicPlayer
  - MidiSynthesizerMusicPlayer
  - MidiOPLMusicPlayer

The MusicPlayer does not have a concept of playlist or any asso-
ciated concepts, such as "skip to next tune." Instead it focuses
on the playing of one tune at a time.

  // It is important to note when using this class that, in gen-
  // eral, calling the member functions may not cause instanta-
  // neous change to the real underlying music player for which
  // this class is a facade. This is because some music players
  // run in other threads and so these interface methods may
  // simply add commands into a queue to be consumed asynchro-
  // nously by the music-playing thread. Hence, change may not
  // take effect immediately and in some cases operations may
  // happen out of order.
  //
  // To help with this there is a method called `fence`. Calling
  // it will cause the calling thread to block until all previous
  // commands sent to the music player have been processed. It
  // also accepts a timeout to avoid hanging if something goes
  // wrong.
  class MusicPlayer {
  public:
    // Verifies that the tune exists on the filesystem in a
    // format that can be read by this player and that the file
    // can be opened. If successfull then it will return a Tune-
    // Info (so this means that it actually has to load and parse
    // the file).
    virtual Opt<TuneInfo> can_play_tune( TuneId id ) = 0;

    // Start playing the given tune from the beginning. When the
    // tune finishes it stops playing until it is given another
    // play command. Returns false if the tune cannot be played.
    virtual bool play( TuneId id ) = 0;

    // If playing will stop the player from playing music.
    virtual void stop() = 0;

    // Returns a structure giving the current state of the
    // player, such as whether it is playing a tune, progress
    // through the tune, volume, etc.
    virtual MusicPlayerState state() const = 0;

    // Returns info on what this music player is capable of do-
    // ing. E.g., can it seek within a tune, can it adjust vol-
    // ume, etc.
    virtual MusicPlayerCapabilities capabilities() const = 0;

    // -- Synchronization ---------------------------------------
    // To help ensure that operations on the music player are
    // well-ordered one calls `fence` before an operation that
    // must wait until previous operations have completed before
    // running. Calling it will cause the calling thread to block
    // until all previous commands sent to the music player have
    // been processed.
    //
    // It also accepts a timeout to avoid hanging if something
    // goes wrong. If a timeout occurs then the function returns
    // false, otherwise true.
    virtual bool fence( Opt<Duration_t> timeout );

    // This one is a more passive aid in making sure that music
    // player commands are well-ordered. It simply returns true
    // the music player is still processing previous commands. It
    // is guaranteed safe to send new commands to the music
    // player regardless of whether it is processing or not, but
    // one will might want to call this to aid in e.g. disabling
    // GUI elements while waiting for the music player to enact
    // the last command.
    virtual bool is_processing() const;

    // -- Optional Extensions -----------------------------------
    // The functions below may or may not be supported by a given
    // music player. If called on a player that doesn't support
    // them they will throw an exception on a debug build and
    // just log an error on a release build.

    // Pause playing of current tune. No-op if no tune is playing
    // or most recent tune has finished.
    virtual void pause();

    // Resume playing of paused tune. No-op if no tune is playing
    // or if most recent tune has finished.
    virtual void resume();

    // Get/Set current volume [0, 1.0].
    virtual void set_volume();

    // Seek to given position in current tune. position in [0,1].
    virtual void seek( double position );
  };

  struct MusicPlayerState {
    // TuneInfo struct for currently playing tune, if any.
    Opt<TuneInfo> tune_info;
    // If the player is currently playing a tune then it will re-
    // turn a number in [0,1.0] representing the progress through
    // the tune. Returns `nullopt` if no tune is playing or if
    // the most recent tune has finished.
    Opt<double> progress;
    // If the player is paused in the middle of a tune.
    bool is_paused;
    // If the player has a notion of settable volume then this
    // will be populated.
    Opt<double> volume;
  };

  struct TuneInfo {
    TuneId     id;
    Duration_t length;
  };

  struct MusicPlayerCapabilities {
    bool can_pause{false}; // implies that it can also resume
    bool has_volume{false};
    bool has_progress{false};
    bool has_tune_duration{false};
    bool can_seek{false};
  };

Each subclass must have a static method with signature:

  static MusicPlayerInfo const& player();

  struct MusicPlayerInfo {
    // E.g. "MIDI File Player"
    std::string name;

    // E.g. "Plays MIDI files using a player-supplied softsynth"
    std::string description;

    // E.g. "To use this music player you must have..."
    std::string how_it_works;

    // Will be non-null if the player successfully initialized
    // and is able to play music. Otherwise will contain an error
    // indicating why.
    expect<Ref<MusicPlayer>> player;
  }

If the player has been initialized properly and is able to play
music then the `player` member will refer to the (singleton) in-
stance of that player.

Tune Representation (tune.h/tune.cpp)
===================

Tunes and/or tune names will not be known at compile time. Tunes
will be referenced at runtime by IDs only. There should be no
part of a game that has a particular tune or tune name
hard-coded.

Tunes will be listed in the config files as a list of Tune ob-
jects that classify the tune along various enum dimensions:

  enum class e_tune_tempo           { fast, medium, slow };
  enum class e_tune_genre           { trad, classical };
  enum class e_tune_culture         { native, new_world, old_world };
  enum class e_tune_instrumentation { fife_and_drum, fiddle, percussive, orchestrated };
  enum class e_tune_sentiment       { happy, sad, war_triumph, war_lost };
  enum class e_tune_key             { a,bb,b,c,cs,d,eb,e,f,fs,g,ab };
  enum class e_tune_tonality        { major, minor };
  enum class e_tune_epoch           { standard, post_revolution }

The API for managing tunes will, to the furthest extent possible,
only use tune IDs and the above dimension enums. That way, it
will force client code to be written in such a way that does not
depend on the precise set of tunes that are available. For exam-
ple, we do not want a section of the game to say "when event X
happens play tune Y". Instead, it will say "when event X happens
play a tune that meets the following classification dimensions or
is as close to it as possible."

Despite the above, there will be an API for getting the name of a
tune for displayin the GUI. Also, the location of a tune (in a
particular format) on the filesystem will consist of a folder
path to the files of that type (specified in the config files)
joined with a string tune identifier (plus extension). The string
identifier will be available for each tune via the API, and must
follow these rules:

  - Must adhere to the regex: [a-z0-9-]+
  - Must be unique
  - Must correspond to the stem of the filename of the tunes in
    the filesystem (for any extention/type).

  struct Tune {
    string display_name;
    string stem;
    string description;

    // Classification.
    e_tune_tempo           tempo;
    e_tune_genre           genre;
    e_tune_culture         culture;
    e_tune_instrumentation instrumentation;
    e_tune_sentiment       sentiment;
    e_tune_key             key;
    e_tune_tonality        tonality;
    e_tune_epoch           epoch;
  };

The API for the tune module will be such as to deal in TuneId's
rather than string names, with the goal that client code should
not interact with tunes based on names in any way, but instead
should interact with them only through their classification di-
mensions.

UI Auto-Pad
===========

+--------------+-----------------------+------------------------+
|              |                       |                        |
|              |                       +------------------------+
|              |                       |                        |
|              |                       |                        |
|              +-----------------------+                        |
|              |                       |                        |
|              |                       |                        |
|              |                       |                        |
|              +-----------------------+------------------------+
|              |                                                |
|              |                                                |
|              |                                                |
|              |                                                |
|              |                                                |
|              |                                                |
|              |                                                |
|              |                                                |
|              |                                                |
+--------------+------------------------------------------------+

Algo:

  // f will take a view and put spacing in all the innards of it,
  // but not the outter edge.
  f( view v ) {
    for each child view cv of v:
      cv = f( cv )
     create hash map(s) to store borders added at this level.
    for each child view cv of v:
      for each side of cv:
        add padding if there is none touching it
  }

  f( main_view )

Mouse Selection of Units
========================

Problem: currently, when units are given Fortify or Sentry orders
there is not simple way to clear those orders, and there is no
way to use the mouse to select a unit for receiving orders.

In the viewport either at an end-of-turn or when units are
blinking one will be able to click on a square with units and ei-
ther clear their orders or ask them to ask for orders. The way
this works depends on how many units there are on a square.

1) Single unit (if ship, must have no units):

  a) During end of turn
    1. Has no orders
      No action.
    2. Has orders
      Orders are cleared.

  b) Not end of turn
    1. Has no orders
      The unit is placed at the front of the orders queue.
      Whether it moves this turn will depend if it has already
      moved or not. The unit currently asking for orders remains
      where it is in the queue (it will be processed just after
      the units that were moved to front).
    2. Has orders
      Orders are cleared.

2) All other cases

  a) During end of turn
      Opens window with recursive list of all units in square
      (including cargo units), prioritization disabled.

  b) Not end of turn
      Opens window with recursive list of all units in square
      (including cargo units), prioritization enabled.

Unit selection window:

Window will pop up listing the units in question. They will be
sorted with the following comparison function:

    operator<( unit1, unit2 ) {
      if unit1 can hold cargo and unit2 can not:
        true
      if unit1 is ship and unit2 is not:
        true
      if unit1 strength > unit2 strength:
        true
      false
    }

The units will have their orders shown in the nationality icon.
The player will then be able to click on the units. Upon clicking
on a unit the player will observe the following behavior. Each
click on a given unit will cycle the unit through the following
states (e.g., for a unit that is currently fortified):

    Orders=Fortified:
      Not End-of-turn:
        Fortified --> No Orders --> No Orders+Prioritized --> ...
      End-of-turn:
        Fortified --> No Orders --> ...
    Orders=None:
      Not End-of-turn:
        No Orders --> No Orders+Prioritized --> ...
      End-of-turn:
        No Orders --> ...

The window will have an creation option to disable the prioriti-
zation states and this will be used on end-of-turn.

On each click, the nat icon will change to reflect the orders
status, but the real underlying unit will not be modified until
the player clicks OK and closes the window. If the state is in a
"prioritized" one then there will be a white highlight/border
around the unit.

When finished the user can press OK to accept the changes, or
Cancel to cancel. "Accepting changes" here means that the under-
lying units will have their orders cleared as requested and pos-
sibly that some units will be moved to the front of the orders
queue.

After a unit has its orders cleared it will be eligible to move
in that same turn if it didn't already move in that turn. So
e.g., if a unit is Fortified in one turn they can be reactivated
in the same turn, but they won't be able to move again until the
next turn; this is because the act of fortifying will remove the
unit's movement points.

Graphical Layout:

The units will be arranged in a vertical line with their names
printed along side. Sorting of units is as described above.

Note that even units in the square that already have their orders
cleared will still show up in the window to avoid confusing the
player.

Implementation. There will be the following new views:

  - SpriteView: displays a sprite.

  - FakeUnitView: displays a unit and optionally a nat. icon, not
    necessarily corresponding to any real or existing unit. This
    will contain a SpriteView by composition.

  - ClickableView: a view that holds a single other view and
    adapts it into something clickable, that is, when clicked it
    calls a callback (does not pass the click through to the un-
    derlying view because that view would not handle it by as-
    sumption.

  - BorderView: a view that contains a boolean that, when true,
    causes a highlight/border of a given color to be painted
    around the contained view.

  - HorizontalArrayView: a view that takes multiple views and
    renders them horizontally with top/bottom/middle alignment.

  - PaddingView: a view that takes another view and just adds
    some padding around it.

  - VerticalArrayView: a view that wraps a list of views and dis-
    plays them vertically. This will inherit from VectorView. On
    creation, one can specify how to justify the views, either
    left, right, or center. This question of justification arises
    because the views in the array will generally have different
    widths.

  - VerticalScrollView: this will be needed because the contents
    will sometimes be too big to fit on screen. However, for now,
    it will be left as a stub with no scrolling.

  - OkCancelView: a view that contains an OK and Cancel button
    net to each other (can specify either vertically or horizon-
    tally) and provides a callback that indicates either OK or
    Cancel.

  - OkCancelAdapter: a view that takes another view and adds a
    pair of OK/Cancel buttons at the bottom using a VerficalAr-
    rayView containing two rows, one with adapted view and one
    with the buttons, layed out horizontally and centered hori-
    zontally.

Here is the view structure:

    OkCancelAdapter
    +-VerticalArrayView
      +-VerticalScrollView
      | +-VerticalArrayView
      |   |-...
      |   |-HorizontalArrayView
      |   | |-OneLineTextView
      |   | +-AddSelectBorderView
      |   |   +-ClickableView
      |   |     +-FakeUnitView
      |   |       +-SpriteView
      |   +-...
      +-OkCancelView
        |-ButtonView
        +-ButtonView

Then there will be a ok_cancel_window function will will take a
view and will use the OkCancelAdapter to show it in a window
along with two OK/Cancel buttons at the bottom and will keep the
window open until the user presses one of the buttons.

At that point, any changes made will be gathered and applied.
Calling unit.clear_orders() should be sufficient. Furthermore, if
there were any units selected for prioritization then this list
will be returned and applied by the `turn` module.

Eventually the VerticalScrollView can be implemented and that
will automatically add a scroll bar to the window if it gets too
vertically long.

Button Views
============

// Handles rendering the button in pressed, non-pressed, or dis-
// abled state, keeps track of state, renders text. Does not
// handle input, and has no callbacks.
class ButtonViewBase;

// Represents a button that springs back up when clicked. Handles
// input, and has a callback that gets called on each click.
class ButtonView;

Mouse Leave Events
==================

Mouse-Move events are only sent to the view that is under the
target coordinate of a mouse move. If the mouse moves out of a
view in a single jump then that view will not recieve notifica-
tion of this (to the view, it would be as if the mouse did not
move at all).

Therefore, when the mouse leaves a view there will be a mouse
leave event sent to it with this signature:

  virtual void on_mouse_leave();

There will be no mouse coordinates given because it is not sup-
pose to be relevant. For completeness and consistency (and be-
cause it will be easy to implement) there will also be a corre-
sponding mouse enter event:

  virtual void on_mouse_enter();

although technically this is not necessary since the view will
receive a mouse move event when the mouse enters.

The way this is implemented is the following. First add an API
method to the ui::Object class (pure virtual) that will be called
with a coordinate (relative to the view origin) and which will
add any views (either itself of children) into a set that overlap
that coordinate:

  using ObjectSet = absl::flat_hash_set<ui::Object const*>;
  virtual void children_under_coord( Coord where,
                                     ObjectSet& objects ) = 0;

Then, when the window manager receives a mouse motion event, it
will call the above function on both the previous position and
the current position and take the disjunction of the sets. Any
views under the old position but not the new position will have
their on_mouse_leave method called, and conversely for
on_mouse_enter.

Text Rendering with Markup
==========================

RN will have a mechanism for rendering text with markup to modu-
late the style. The user interface for this will be that the user
will be able to pass in some text with special markup syntax
among the text and this will be interpreted and rendered with the
appropriate style.

The workflow of this implementation (and its interaction with a
word wrap) will be as follows:

  1) The user provides some text which may contain some markup
     tags.
  2) The text is flattened onto a single line if it is multiline
  3) The text is then wrapped (if requested) in such a way that
     markup characters are ignored (but still remain intact)
     in the wrapping.
  4) Each resulting line is parsed for markup characters and
     translated into a vector of markup descriptor objects, with
     each object containing a segment of text.
  5) When parsing a given line, the start of the line will be
     given the markup state from the end of the last line.
  6) At this point we have a vector of self-contained lines
     each of which is a vector of markup descriptor objects.
     Each of these lines will be sent to a rendering function
     that will render them with caching at the line level.
     This rendering will be done one character at a time.
  7) Then the lines will be rejoined into a paragraph.

Initially, this will just focus on a single markup feature: high-
light or no highlight.  The syntax will be as follows:

  "This is a @Htest@N.  In@Hs@Nide letters can be highlighted."
  "This is an email@@address.com with escaping."

Menu Item Click Handling
========================

  Menu Module
  -----------

  In order to avoid all menu handler code going into the menu
  module, it will be possible for modules to register handlers
  for menu items. This will consist of a void( e_menu_item )
  function to handle a click on the menu item and a
  bool(e_menu_item) function to return if the menu item should be
  enabled or disabled. The functions take arguments so that a
  registerer can use the same function for multiple items and use
  branching within the function to distinguish menu items.

    MENU_ITEM_HANDLER( game, save, is_enabled_func, handler_func );

  will roughly expand to:

    STARTUP() {
      register_menu_item_handler(
        e_menu_item::save_game,
        handler_func,
        is_enabled_func
      );
    }

  All menu items must have precisely one handler registered, and
  this is enforced during initialization.

  The menu module will call the is_enabled_func for each menu
  item each frame (so they should be light-weight). If a menu
  item is not enabled then it will be shown as disabled. If all
  menu items in a menu are disabled then that menu will not be
  shown.

  When a menu item is clicked (and it is enabled) then the
  handler_func will be called.

  Plane Module
  ------------

  Although some menu items might have handlers registered
  throughout the code base, most menu items will have handlers
  registered in the `plane` module.

  The plane module's implementation of the two callback methods
  will call a new virtual method on each of the Plane objects
  that asks the Plane for a handler function for a particular
  menu item. Specifically, the Plane will return:

    using MenuHandler = function<void()>;

    OptRef<MenuHandler> f( e_menu_item item ) {
      if( item == e_menu_item::restore_zoom ) {
        static MenuHandler handler = [this] {

        };
        return handler;
      }
      if( item == e_menu_item::sentry ) {
        static MenuHandler handler = [this] {

        };
        return handler;
      }
      return nullopt;
    }

  The plane module will cycle through the planes (from outer to
  inner) to find the first plane that can handle the menu item
  (i.e., returns non-nullopt).

  If at least one Plane returns a result that is not nullopt then
  that is taken as an indication that the menu item is enabled
  (otherwise it is disabled), and the function object contained
  therein (from the top-most (enabled) Plane that returned one)
  will be called to handle it if it is clicked.

  This new virtual method on Plane will have a default implemen-
  tation that just returns nullopt.

Menus
=====

  User Experience
  ---------------

  There will be a menu bar at the top of the screen. The user,
  when the game is open for input, will be able to open a menu
  and select an item. Alternatively they can use Alt-<Key> and
  the arrow keys to open menus.

  The menus that appear will generally depend on the state of the
  game. For example, when the user enters the europe view an ad-
  ditional menu might appear that allows the user to perform ac-
  tions relevant there. This might supplement some buttons that
  are already in that view.

  At some points in the game, such as when AI nations are making
  their moves, the menus will be off, in which case the menu bar
  will be empty (perhaps with the exception of save/quit/pause;
  this is yet to be decided). If all menus are off then the menu
  bar will disappear, possibly with a sliding animation.

  When the user clicks a top-level menu it will open and remain
  open even after releasing the mouse button. Hovering the mouse
  over the menu items will highlight each item, unless it happens
  to be disabled. Clicking on a menu item will animate a brief
  flash. While the menu is open, the top-level menu name will be
  highlighted, and dragging the mouse over other top-level menu
  items will open that particular menu without necessitating more
  clicks.

  Dragging: the user can also interact with the menus in the
  "dragging style". In this way, the user selects a top-level
  menu and keeps the mouse button held down, then moves to a menu
  item and releases the button. Upon release of the button the
  menu item will be selected.

    * Selecting menu items may cause windows to open, but the
      consequences of this might have to be dealt with separately.
    * Some items might be disabled depending on general game state
    * If all items in a top-level menu are disabled then that
      menu will be hidden.
    * If a menu is open and the user clicks outside of all menu
      UI items then then menu will close and the click will have
      a click-through behavior where it will be resent through the
      planes (still to be decided).
    * There can be dividers between groupings of menu items.

  Most menus will be on the left side of the screen, but some may
  be right justified, such as the Revolopedia menu.

  There will be a global function that can turn on/off all menus;
  when this happens the menus will disappear (maybe).

  Rendering
  ---------

    * There will be a shadow under open menus.
    * Hot-key letter of menu will be highlighted.

Combat
======

From a high level: when a unit with non-zero attack attempts to
enter a square with a unit form another nation then:

  a) If the two nations are at peace then a yes/no box pops up
     asking for confirmation.
  b) If not at peace then the attack just proceeds.

When the move is first is attempted the combat stats and outcome
will be computed during the analysis phase, even before any
confirmation boxes are presented to the player. If the player
proceeds then the previously-computed outcome is animated and
carried out. However, even though the outcome of the combat is
known before the confirmation is presented, the player will
obviously not be presented with the outcome until deciding to
proceed and seeing the animation.

If a unit attempts to attack with less than a full movement point
then they will take a penalty for that.

If there are multiple units in the target square then the one with
the best defense will be picked.

Each attack will consume only one movement point, so some units
may be able to attack multiple times per turn.  If a unit gets
demoted after an attack the resulting number of movement points
will be min( X, Y ) where X is the max movement points for the
demoted unit and Y is the number of movement points that the
non-demoted unit would have had had the attack been successful.

Mouse Dragging
==============

The mouse dragging framework will span a few different frameworks:

  1) The `input` module that translates the raw SDL event.

      The `input` module will supply two pieces of information
      with each event: whether a drag is in progress (and, if so,
      the point from which the dragging started) and a signal as
      to when it finishes. The former will generally span many
      events while the latter will correspond to just a single
      event.

      This module will communicate to the next stage the fol-
      lowing information: if the `engaged` field of the mouse
      state is set then that means that the drag is either in
      progress or just finished. If the `done` flag is set then
      the drag is just finished; the receiver of this event must
      be sure to react to this `done` event because the drag
      state will be reset on the very next event.

  2) The Plane module

      The `plane` module will intercept the dragging events and
      propagate them to the planes in a different way. When it
      detects a dragging event it will send it to the planes not
      through the usual input way but through some dedicated
      methods that distinguish dragging start/middle/end. Fur-
      thermore, when a new dragging event starts and a plane ac-
      cepts it then that same plane will continue to receive the
      dragging events for that dragging move until it ends. This
      way a user cannot start dragging on one plane and drag onto
      another.

  3) (where relevant) the window module

Auto-commands
=============

It will be useful for various purposes:

  * Unit movement that happens as a result of some different
    command, such as:
      * land-fall automatically unloading a unit
      * combat capturing a unit
      * other things
  * Cut scenes (animated sequences)
  * Testing

for units to be able to take orders automatically instead of
polling the user.  To this end, we do the following:

  For units there will be a global orders queue that will hold
  player orders.  When a unit needs orders this queue will be
  checked first, and then the order will be taken a processed
  as if the user had entered it manually, including any popup
  windows that might be needed.

  If a unit needs orders and there are none in the queue then
  (and only then) will the user be polled.

Applications:

  * When a ship is making landfall then the first unit onboard
    with available movement points will be given an auto command
    to move onto land.  It will also be push to the front of the
    orders queue, and the ship will "wait".  The unit will then
    immediately execute the order.  All units on the ship with
    movement points will be given the order.

Planes
======

There will be a fixed, ordered list of planes. There will be a
global enum with values for each plane, and this enum will reside
in the plane module.

The plane objects themselves will reside in the module that han-
dles rendering to it, and will in general refer to methods in
that module for input handling and rendering. The plane objects
will be gathered by the plane module and held in a central loca-
tion, keyed off of the enum.

For each plane there will be a texture the size of the screen. To
render the screen the planes are drawn in order. We do not reuse
the same texture just in case a plane decides that it does not
need to render on every frame (e.g., a plane that just displays
an image would only need to do so once).

A plane has the following methods/attributes:

  - enabled
  - draw.  This method will be given the texture.  (which the
    plane module manages and which will be automatically set
    as the rendering target).  The texture will be initialized
    with zero alpha everywhere. The draw method will be given, as
    a parameter, a value indicating the phase of animations,
    one for periodic and another monotonically increasing.
  - accept input, returning true/false depending on whether
    the input was handled or not.
  - covers_screen. In that case, and if the plane is enabled,
    planes under it are not rendered since they would not be
    visible (for efficiency).

The plane module will handle executing the drawing routines to
assemble the composite of the planes and their layers.

Input handling: user input in general will be passed through the
planes starting with the outer most one until a plane decides to
handle that input, at which point no further planes will be given
the opportunity to handle it. A plane must know how to accept
input and change its state accordingly.

Planes:
  0) Land/Units
  1) Panel
  2) Colony View
  3) Europe View
  4) Menus
  5) Images
  6) Windows
  7) Console

The compositor will produce a final texture that can then be
rendered to the main one.

Units on ships:
===============

  ✓ Each time a ship moves, all the units it contains will have
    their orders changed to `sentry`, in case the player activated
    a unit but never moved it onto land.
  ✓ If a unit is activated on a ship and the ship is waiting for
    orders and the player either hits `wait` or `pass` then this
    will not change the status of the unit in any way.
  * If a player clicks on a ship and actives units then their orders
    will be cleared and, if they have not already moved this turn,
    they will ask for orders at some point before the end of the
    turn.  If this happens at the end of turn then the units will
    ask for orders next turn.
  ✓ If a unit is activated on a ship and is waiting for orders and
    the user presses `wait` then the game will come back to the
    unit, assuming that the ship did not move in the mean time
    (which would have changed the unit back to `sentry`).
  ✓ If a unit is waiting for orders on a ship and the player hits
    `pass` then the unit's orders will not change.
  ✓ If a unit is waiting for orders on a ship then the only valid
    commands are: movement onto land, movement onto ship, wait,
    pass, sentry.
  * A unit waiting for orders on a ship cannot attack direcly from
    the ship (maybe a special unit could do this).
  ✓ A unit waiting for orders on a ship can move onto an adjacent
    ship of the same nationality, which consumes all their movement
    points.
  ✓ When a unit boards a ship it consumes all their movement pts.
  ✓ When a unit offboards a ship it consumes all their movement pts.
  ✓ When a ship carrying units attempts to move onto land:
     ✓ The ships movement points are NOT consumed.
     ✓ If there are no units with movement points then nothing happens.
     ✓ If there are units with movement points then:
        ✓ A window pops up asking if we want to make landfall.
        ✓ If yes, the following happens:
            ✓ All the units with movement points on the ship have
              their orders cleared.
            ✓ The units in the ship with movement
              points moves onto the land automatically.
            ✓ All the other units on the ship with movement points
              are put on the priority list to take orders next.
            ✓ The ship itself is given a `wait` order automatically.
            ✓ As a consequence of the above, the next unit on board
              with movements points starts to blink.

================================================================

Game loops:
==========

  start of turn:

    Iterate through the colonies, for each:

      * advance state of the colony

      * display messages to user any/or show animations where necessary

      * allow them to enter colony when events happens;
        in that case go to the colony screen game loop.When the user
        exits the colony screen then this colony iteration
        immediately proceeds;
        i.e., user cannot enter any other colonies.  This prevents the
        user from making last-minute changes to colonies that have not
        yet been advanced in this turn (otherwise that might allow
        cheating in some way).

      * during this time, the user is not free to scroll
        map (menus?) or make any changes to units.  They are also
        not allowed to enter colonies apart from the one that has
        just been processed.

    Advance the state of the old world, possibly displaying messages
    to the user where necessary.

    Iterate through all units, for each:

      * if it is it in `goto` mode focus on it and advance it
      * if it is a ship on the high seas then advance it
          if it has arrived in the old world then jump to the old world
          screen (maybe ask user whether they want to ignore),
          which has its own game loop (see old-world loop).
      * if it is in the old world then ignore it, or possibly remind
        the user it is there.
      * if it is performing an action, such as building a road,
        advance the state.  If it finishes then mark it as active
        so that it will wait for orders in the next step.
      * if it is in an indian village then advance it, and mark
        it active if it is finished.

      * if unit is waiting for orders then focus on it, and enter
        a realtime game loop where the user can interact with the
        map and GUI in general.  See `unit orders` game loop.

      * Make AI moves
          Make European moves
          Make Native moves
          Make expeditionary force moves

          Might want to do this in the Processing loop

      * if no player units needed orders then show a message somewhere
        that says "end of turn" and let the user interact with the
        map and GUI.

  Unit orders game loop:

    while state != unit accepted orders:

      render:
        render the the world without any units on it.  Color cycling
        animations here will use SDL_GetTicks to decide animation state.

        render all the colonies

        render all the units, with the focus animation using SDL_GetTicks
        to decide animation state.

      if state == unit awaiting orders && if input received:
        check if input valid
        if so then iniate movement animation, setting state to animation.
        ? need to figure this out more, but initially skip animations ?

      if state == animation:
        advance animation;
        if animation finished the mark state as
        `unit accepted orders`

      delay to maintain frame rate

  End of turn game loop:

  Colony screen game loop:

  Old World game loop:

  Message-window-over-world game loop:

    * This needs needs to be able to show a message and let the
      user interact with it while possibly still showing animations
      on the map in the background, but not letting the user interact
      with the map.

  Unit animation game loop: (needed?)

    * This includes sliding units and animations resulting from
      e.g. city upgrades.

  Processing game loop:

    * Any intensive processing task should probably be done in
      a separate thread with a loop running so that things remain
      responsive.
